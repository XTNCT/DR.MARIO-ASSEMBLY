################# CSC258 Assembly Final Project ###################
# This file contains our implementation of Dr Mario.
#
# Student 1: Ishaan Pandey, 1010334880
# Student 2: Shuhao Zhao, 1007799688
#
# We assert that the code submitted here is entirely our own 
# creation, and will indicate otherwise when it is not.ddddddddddddd
######################## Bitmap Display Configuration ########################
# - Unit width in pixels:       8
# - Unit height in pixels:      8
# - Display width in pixels:    512
# - Display height in pixels:   512
# - Base Address for Display:   0x10008000 ($gp)
##############################################################################

    .data
##############################################################################
# Immutable Data
##############################################################################
  # The address of the bitmap display. Don't forget to connect it!
  ADDR_DSPL:
      .word 0x10008000
  # The address of the keyboard. Don't forget to connect it!
  ADDR_KBRD:
      .word 0xffff0000
  
  # Color-palette
  color_palette: .word 0xff0000, 0x0000ff, 0xffff00 # Red, Blue, Yellow (RGB format)
  
  Red: .word 0xff0000
  Blue: .word 0x0000ff
  Yellow: .word 0xffff00
  White: .word 0xFFFFFF
  Black: .word 0x000000
  Skin: .word 0xFFCC99
  
  V_Red: .word 0xFF8080
  V_Blue: .word 0x8080FF
  V_Yellow: .word 0xFFFF99

  # Dr. Mario's sprite 
  Dr_Mario_Sprite:
    # Each .word represents a pixel's color in hexadecimal (RRGGBB)
    .word 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x896129, 0x000000, 0x000000, 0x000000
    .word 0x000000, 0x000000, 0x000000, 0x000000, 0x896129, 0x896129, 0x896129, 0x896129, 0xD3D3D3, 0xFFFFFF, 0x896129, 0x000000, 0x000000, 0x000000
    .word 0x000000, 0x000000, 0x000000, 0x0047AB, 0x0047AB, 0x0047AB, 0x0047AB, 0x0047AB, 0xD3D3D3, 0xFFFFFF, 0x000000, 0x000000, 0x000000, 0x000000
    .word 0x000000, 0x000000, 0x000000, 0x896129, 0x896129, 0x896129, 0xF2CCB7, 0xF2CCB7, 0x000000, 0xF2CCB7, 0x000000, 0x000000, 0x000000, 0x000000
    .word 0x000000, 0x000000, 0x896129, 0xF2CCB7, 0x896129, 0xF2CCB7, 0xF2CCB7, 0xF2CCB7, 0x000000, 0xF2CCB7, 0xF2CCB7, 0xF2CCB7, 0x000000, 0x000000
    .word 0x000000, 0x000000, 0x896129, 0xF2CCB7, 0x896129, 0x896129, 0xF2CCB7, 0xF2CCB7, 0xF2CCB7, 0x000000, 0xF2CCB7, 0xF2CCB7, 0xF2CCB7, 0x000000
    .word 0x000000, 0x000000, 0x896129, 0x896129, 0xF2CCB7, 0xF2CCB7, 0xF2CCB7, 0xF2CCB7, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000
    .word 0x000000, 0x000000, 0x000000, 0x000000, 0xF2CCB7, 0xF2CCB7, 0xF2CCB7, 0xF2CCB7, 0xF2CCB7, 0xF2CCB7, 0xF2CCB7, 0xF2CCB7, 0x000000, 0x000000
    .word 0x000000, 0x000000, 0x000000, 0xFFFFFF, 0xFFFFFF, 0xD3D3D3, 0xFFFFFF, 0xFF0000, 0xFF0000, 0xFF0000, 0x000000, 0x000000, 0x000000, 0x000000
    .word 0x000000, 0x000000, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xD3D3D3, 0xFF0000, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0x000000, 0x000000
    .word 0x000000, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xD3D3D3, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0x000000
    .word 0x000000, 0xD3D3D3, 0xD3D3D3, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xD3D3D3, 0xD3D3D3, 0xFFFFFF, 0xFFFFFF, 0xD3D3D3, 0xD3D3D3, 0x000000
    .word 0x000000, 0xD3D3D3, 0xD3D3D3, 0xD3D3D3, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xD3D3D3, 0xD3D3D3, 0xD3D3D3, 0x000000
    .word 0x000000, 0xD3D3D3, 0xD3D3D3, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xD3D3D3, 0xD3D3D3, 0x000000
    .word 0x000000, 0x000000, 0x000000, 0x0047AB, 0x0047AB, 0x0047AB, 0x000000, 0x000000, 0x0047AB, 0x0047AB, 0x0047AB, 0x000000, 0x000000, 0x000000
    .word 0x000000, 0x000000, 0x896129, 0x896129, 0x896129, 0x000000, 0x000000, 0x000000, 0x000000, 0x896129, 0x896129, 0x896129, 0x000000, 0x000000
    .word 0x000000, 0x896129, 0x896129, 0x896129, 0x896129, 0x000000, 0x000000, 0x000000, 0x000000, 0x896129, 0x896129, 0x896129, 0x896129, 0x000000

  Virius_B_Sprite:
    # Each .word represents a pixel's color in hexadecimal (RRGGBB)
    .word 0x000000, 0x000000, 0x8080FF, 0x8080FF, 0x8080FF, 0x8080FF, 0x8080FF, 0x000000, 0x000000
    .word 0x000000, 0x8080FF, 0x8080FF, 0x8080FF, 0x8080FF, 0x8080FF, 0x8080FF, 0x8080FF, 0x000000
    .word 0x8080FF, 0x8080FF, 0xffff00, 0x000000, 0x000000, 0x000000, 0x000000, 0x8080FF, 0x8080FF
    .word 0x8080FF, 0x8080FF, 0x000000, 0x000000, 0x000000, 0x000000, 0xffff00, 0x8080FF, 0x8080FF
    .word 0x8080FF, 0x8080FF, 0x8080FF, 0x8080FF, 0x8080FF, 0x8080FF, 0x8080FF, 0x8080FF, 0x8080FF
    .word 0x8080FF, 0x8080FF, 0x8080FF, 0x8080FF, 0x8080FF, 0x8080FF, 0x8080FF, 0x8080FF, 0x8080FF
    .word 0x8080FF, 0x8080FF, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x8080FF, 0x8080FF
    .word 0x000000, 0x8080FF, 0x000000, 0xff0000, 0xff0000, 0x000000, 0x000000, 0x8080FF, 0x000000
    .word 0x000000, 0x000000, 0x8080FF, 0xff0000, 0x8080FF, 0x8080FF, 0x8080FF, 0x000000, 0x000000

  Virius_R_Sprite:
    # Each .word represents a pixel's color in hexadecimal (RRGGBB)
    .word 0x000000, 0xFF8080, 0xFF8080, 0xFF8080, 0xFF8080, 0xFF8080, 0xFF8080, 0xFF8080, 0x000000
    .word 0xFF8080, 0x000000, 0xFF8080, 0xFF8080, 0xFF8080, 0xFF8080, 0xFF8080, 0x000000, 0xFF8080
    .word 0xFF8080, 0x000000, 0x000000, 0x000000, 0xFF8080, 0x000000, 0x000000, 0x000000, 0xFF8080
    .word 0xFF8080, 0xFF8080, 0x000000, 0xff0000, 0x000000, 0xffff00, 0x000000, 0xFF8080, 0xFF8080
    .word 0xFF8080, 0xFF8080, 0xFF8080, 0xFF8080, 0xFF8080, 0xFF8080, 0xFF8080, 0xFF8080, 0xFF8080
    .word 0xFF8080, 0xFF8080, 0xFF8080, 0x000000, 0x000000, 0x000000, 0xFF8080, 0xFF8080, 0xFF8080
    .word 0xFF8080, 0xFF8080, 0x000000, 0xFF8080, 0xFF8080, 0xFF8080, 0x000000, 0xFF8080, 0xFF8080
    .word 0x000000, 0xFF8080, 0xFF8080, 0xFF8080, 0xFF8080, 0xFF8080, 0xFF8080, 0xFF8080, 0x000000
    .word 0x000000, 0x000000, 0xFF8080, 0xFF8080, 0xFF8080, 0xFF8080, 0xFF8080, 0x000000, 0x000000

  Virius_Y_Sprite:
    # Each .word represents a pixel's color in hexadecimal (RRGGBB)
    .word 0x000000, 0x000000, 0xFFFF99, 0xFFFF99, 0xFFFF99, 0xFFFF99, 0xFFFF99, 0x000000, 0x000000
    .word 0x000000, 0xFFFF99, 0xFFFF99, 0xFFFF99, 0xFFFF99, 0xFFFF99, 0xFFFF99, 0xFFFF99, 0x000000
    .word 0xFFFF99, 0xFFFF99, 0xff0000, 0x000000, 0x000000, 0xff0000, 0x000000, 0xFFFF99, 0xFFFF99
    .word 0xFFFF99, 0xFFFF99, 0xff0000, 0x000000, 0x000000, 0xff0000, 0x000000, 0xFFFF99, 0xFFFF99
    .word 0xFFFF99, 0xFFFF99, 0xFFFF99, 0xFFFF99, 0xFFFF99, 0xFFFF99, 0xFFFF99, 0xFFFF99, 0xFFFF99
    .word 0xFFFF99, 0xFFFF99, 0x000000, 0xFFFF99, 0xFFFF99, 0xFFFF99, 0x000000, 0xFFFF99, 0xFFFF99
    .word 0xFFFF99, 0xFFFF99, 0xFFFF99, 0x000000, 0x000000, 0x000000, 0xFFFF99, 0xFFFF99, 0xFFFF99
    .word 0x000000, 0xFFFF99, 0xFFFF99, 0xFFFF99, 0xFFFF99, 0xFFFF99, 0xFFFF99, 0xFFFF99, 0x000000
    .word 0x000000, 0x000000, 0xFFFF99, 0xFFFF99, 0xFFFF99, 0xFFFF99, 0xFFFF99, 0x000000, 0x000000

Game_Over_Sign_Sprite:
    # Each .word represents a pixel's color in hexadecimal (RRGGBB)
    .word 0x000000, 0xff0000, 0xff0000, 0x000000, 0x000000,0x000000, 0xff0000, 0x000000, 0x000000, 0x000000, 0xff0000, 0x000000, 0x000000, 0xff0000, 0xff0000, 0x000000, 0x000000, 0x000000, 0xff0000, 0xff0000, 0x000000, 0x000000, 0x000000, 0xff0000, 0x000000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0xff0000, 0xff0000
    .word 0xff0000, 0x000000, 0x000000, 0xff0000, 0x000000,0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0xff0000, 0xff0000
    .word 0xff0000, 0x000000, 0x000000, 0x000000, 0x000000,0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0x000000, 0x000000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0xff0000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0x000000
    .word 0xff0000, 0x000000, 0x000000, 0x000000, 0x000000,0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0x000000, 0x000000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0x000000
    .word 0xff0000, 0x000000, 0xff0000, 0xff0000, 0x000000,0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0xff0000, 0x000000, 0xff0000, 0xff0000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0xff0000, 0xff0000
    .word 0xff0000, 0x000000, 0x000000, 0xff0000, 0x000000,0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0xff0000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0x000000
    .word 0xff0000, 0x000000, 0x000000, 0xff0000, 0x000000,0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0x000000
    .word 0xff0000, 0x000000, 0x000000, 0xff0000, 0x000000,0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0xff0000, 0xff0000
    .word 0x000000, 0xff0000, 0xff0000, 0x000000, 0x000000,0x000000, 0xff0000, 0x000000, 0x000000, 0x000000, 0xff0000, 0x000000, 0x000000, 0xff0000, 0xff0000, 0x000000, 0x000000, 0x000000, 0xff0000, 0xff0000, 0x000000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0xff0000, 0xff0000    


Erase_Game_Over_Sign_Sprite:
    # Each .word represents a pixel's color in hexadecimal (RRGGBB)
    .word 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000
    .word 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000
    .word 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000
    .word 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000
    .word 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000
    .word 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000
    .word 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000
    .word 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000
    .word 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000
   
  
  
  # song:
    dr_mario_song: 
        .word 107, 88, 78, 101, 103, 107, 94, 79, 73, 77, 62, 77, 66, 67, 67, 66, 65, 65, 64, 64, 77, 72, 77, 78, 65, 66, 66, 61, 66, 67, 62, 82, 62, 61, 67, 83, 67, 65, 83, 64, 70, 62, 82, 62, 71, 64, 83, 64, 63, 61, 64, 81, 64, 62, 79, 63, 63, 79, 63, 62, 79, 62, 64, 81, 63, 67, 62, 82, 62, 67, 83, 67, 83, 64, 70, 81, 70, 62, 81, 62, 71, 62, 79, 62, 63, 79, 64, 62, 66, 62, 68, 98, 101, 91, 90, 107, 74, 69, 66, 67, 66, 72, 73, 62, 70, 64, 66, 101, 64, 67, 62, 82, 62, 66, 67, 65, 83, 64, 68, 70, 82, 63, 71, 64, 83, 64, 64, 81, 64, 62, 79, 63, 63, 79, 63, 79, 62, 65, 64, 81, 64, 65, 73, 72, 67, 67, 62, 77, 61, 67, 67, 67, 64, 65, 66, 72, 67, 67, 67, 66, 66, 65, 66, 77, 61, 67, 61, 67, 66, 65, 67, 62, 82, 62, 66, 67, 68, 83, 64, 65, 70, 62, 82, 62, 70, 71, 83, 71, 83, 64, 64, 81, 64, 62, 61, 62, 79, 63, 62, 63, 65, 79, 62, 63, 64, 61, 81, 67, 82, 62, 66, 67, 64, 83, 64, 70, 62, 81, 62, 70, 71, 79, 62, 62, 64, 79, 64, 62, 63, 66, 100, 85, 96, 97, 104, 107, 104, 96, 99, 87, 107, 96, 102, 94, 101, 91, 102, 89, 92, 90, 92, 94, 88, 87, 86, 99, 98, 107, 101, 106, 104, 97, 86, 85, 68, 67, 82, 83, 62, 67, 65, 64, 83, 64, 70, 82, 62, 70, 71, 64, 83, 64, 64, 81, 64, 63, 64, 79, 64, 63, 64, 79, 64, 65, 64, 63, 81, 64, 72, 77, 98, 92, 99, 92, 86, 87, 88, 83, 87, 91, 72, 74, 92, 81, 61, 62, 86, 85, 87, 82, 90, 85, 102, 98, 75, 92, 88, 73, 69, 97, 64, 63, 69, 66, 86, 69, 66, 72, 75, 76, 74, 73, 70, 71, 66, 69, 68, 70, 66, 67, 62, 71, 81, 78, 77, 75, 67, 75, 66, 67, 75, 76, 67, 76, 67, 72, 75, 67, 72, 77, 78, 76, 67, 77, 78, 74, 65, 74, 65, 72, 70, 72, 70, 72, 70, 66, 73, 72, 69, 72, 69, 71, 77, 69, 65, 69, 65, 66, 69, 72, 77, 75, 67, 75, 74, 67, 66, 69, 76, 67, 76, 67, 63, 73, 74, 74, 67, 72, 78, 72, 67, 71, 72, 77, 72, 69, 72, 69, 63, 62, 62, 103, 100, 69, 75, 72, 64, 69, 87, 88, 63, 63, 77, 68, 82, 101, 102, 72, 77, 75, 67, 75, 75, 65, 67, 68, 76, 67, 76, 67, 73, 72, 75, 67, 76, 67, 65, 72, 77, 74, 65, 74, 65, 72, 70, 72, 70, 73, 72, 69, 72, 69, 77, 69, 65, 69, 65, 66, 69, 70, 75, 72, 73, 71, 70, 71, 72, 77, 74, 66, 62, 68, 71, 65, 94, 89, 72, 76, 77, 75, 75, 67, 76, 76, 66, 72, 74, 72, 66, 72, 72, 76, 78, 79, 94, 93, 97, 77, 100, 96, 105, 85, 88, 93, 73, 80, 72, 77, 65, 72, 77, 75, 67, 76, 76, 61, 65, 74, 78, 77, 72, 72, 72, 63, 81, 89, 91, 77, 107, 84, 102, 106, 104, 73, 63, 72, 77, 66, 66, 61, 61, 79, 64, 75, 76, 76, 65, 73, 74, 76, 72, 74, 72, 65, 72, 72, 77, 69, 69, 66, 72, 73, 72, 73, 95, 71, 62, 63, 72, 77, 72, 72, 72, 77, 64, 70, 72, 77, 78, 74, 73, 72

    dr_mario_bass:
        .word 50, 55, 55, 49, 55, 51, 60, 59, 58, 57, 60, 59, 59, 60, 59, 60, 60, 52, 59, 57, 58, 49, 54, 57, 57, 55, 59, 55, 50, 60, 58, 52, 59, 52, 58, 60, 59, 57, 58, 59, 58, 56, 55, 57, 60, 60, 59, 60, 60, 60, 58, 60, 53, 59, 50, 56, 57, 54, 55, 57, 53, 52, 58, 53, 52, 51, 59, 57, 59, 60, 58, 59, 60, 60, 55, 54, 55, 52, 53, 55, 53, 56, 55, 59, 58, 51, 55, 56, 55, 51, 57, 55, 55, 55, 55, 51, 55, 60, 52, 55, 54, 55, 55, 52, 49, 55, 54, 55, 57, 54, 55, 53, 55, 54, 55, 53, 59, 60, 60, 60, 52, 60, 59, 59, 60, 60, 52, 58, 57, 53, 52, 51, 55, 52, 50, 52, 51, 52, 59, 51, 52, 51, 52, 60, 60, 56, 50, 51, 51, 50, 58, 53, 52, 52, 51, 60, 50, 58, 59, 55, 52, 56, 57, 59, 56, 57, 59, 54, 51, 59, 50, 51, 50, 53, 52, 60, 60, 57, 50, 59, 53, 51, 50, 57, 55, 51, 50, 54, 56, 54, 52, 59, 53, 56, 57, 57, 56, 58, 56, 55, 53, 55, 54, 53, 55, 54, 53, 55, 59, 54, 52, 53, 55, 53, 54, 55, 53, 50, 59, 50, 55, 51, 54, 55, 50, 60, 60, 51, 59, 50, 51, 52, 58, 52, 58, 51, 53, 54, 53, 56, 57, 60, 54, 53, 55, 50, 55, 50, 60, 60, 51, 59, 54, 52, 52, 58, 60, 53, 53, 57, 58, 53, 52, 54, 54, 54, 54, 49, 53, 55, 53, 52, 53, 52, 53, 51, 52, 53, 51, 53, 52, 51, 52, 53, 52, 53, 55, 50, 52, 53, 52, 51, 55, 57, 52, 53, 51, 53, 52, 55, 53, 52, 50, 51, 49, 53, 50, 51, 49, 53, 52, 51, 50, 51, 49, 50, 53, 50, 51, 50, 49, 50, 53, 53, 50, 53, 55, 54, 55, 54, 53, 55, 53, 54, 55, 54, 51, 59, 55, 54, 55, 56, 53, 55, 53, 55, 54, 50, 56, 58, 58, 53, 50, 52, 50
    

    dr_note_count:
        .word 612  # Number of melody notes
    
    dr_bass_count:
        .word 355  # Number of bass notes


##############################################################################
# Mutable Data
##############################################################################

  map_height: .word 20
  map_width: .word 25
  
  # Gravity
  gravity_counter: .word 0           # Counts frames until gravity applies
  gravity_threshold: .word 40        # Initial gravity threshold (higher value = slower fall)
  gravity_speed_timer: .word 2       # Counts frames to gradually increase gravity speed
  gravity_acceleration_rate: .word 100  # Number of frames before gravity speeds up
  gravity_increment: .word 10         # Initial value to increment gravity_counter
  min_gravity_threshold: .word 5     # Lowest allowed threshold to prevent too fast dropping
  # Pill data 
  active_pill: .space 28 # Store X1, Y1, X2, Y2, C1, C2, Orientation ( 0 = Horizontal, 1 = Vertical)
  
  collision_map: .space 16 # Store (Up, Down, Left, Right), (0 = free, 1 = blocked)

  displayAddress: .word 0x10008000
  X_L: .word 21
  Y_L: .word 21

  dr_mario_sound_threshold: .word 0
  dr_mario_sound_timer: .word 0
##############################################################################
# Code
##############################################################################
	.text
	.globl main

    # Run the game.
main:
    # Initialize the game
    jal draw_map
    #HERE IAM CALLING THE PILL FUNCTIONS TO TEST 
    li $a0 0
    li $a1 0
    jal Draw_Mario
    li $a0, 20
    li $a1, 2
    jal Draw_Virus_Blue
    li $a0, 35
    li $a1, 2
    jal Draw_Virus_R
    li $a0, 27
    li $a1, 50
    jal Draw_Virus_Y
    jal Spawn_In_Box
    
    jal Draw_pill

    jal Spawn_germ
    jal Spawn_germ
    jal Spawn_germ
    jal Spawn_germ

  # TEST COMMANDS #
    j game_loop


game_loop:
    # 1a. Checks game over conditions
    jal Game_over
    # 1b. Check if key has been pressed
    # 1c. Check which key has been pressed
    jal Handle_Input
    
    # 2a. Check for collisions
    # 2b. Update locations (capsules)

    jal Detect_Collison

    jal Handle_Collision

    jal Apply_Gravity_Pill

  
    # 3a. updates collison of shifted map
    jal Detect_Collison
    
    jal Handle_Collision

    # 3b.Feature Plays Music in the Background
    jal Play_Music
 
    
    # 4. Sleep
    li $v0, 32           # Syscall for sleep
    li $a0, 100          # Sleep for 100 milliseconds
    syscall
    
    # 5. Go back to Step 1
    j game_loop


#############################################
##################FUNCTIONS##################
#############################################

# Game Logic and operation

  Game_over:
      addi $sp, $sp -12
      sw $ra, 8($sp)

      jal get_x1
      sw $v0, 0($sp)

      jal get_y1
      sw $v0, 4($sp)

      jal Is_Blocked_Down
      beq $v0, $zero, complete_game_over

      lw $t0, 0($sp) # X_1
      lw $t1, 4($sp) # Y_1
      
      lw $t2, Y_L   # Top coordinate of map

      beq $t0, $t2, game_over

      game_over:
          jal reset_game
          lw $ra, 8($sp)
          addi $sp, $sp, 12
          li $v0, 10
          syscall

      complete_game_over:
          lw $ra, 8($sp)
          addi $sp, $sp, 12
          jr $ra

  keyboard_input:
      addi $sp, $sp, -8
      sw   $ra, 4($sp)
      sw   $a0, 0($sp)
  
      li $t1, 0x71          # 'q'
      beq $a0, $t1, respond_to_Q
  
      li $t1, 0x61          # 'a'
      beq $a0, $t1, respond_to_A
  
      li $t1, 0x64          # 'd'
      beq $a0, $t1, respond_to_D
  
      li $t1, 0x73          # 's'
      beq $a0, $t1, respond_to_S
  
      li $t1, 0x77          # 'w'
      beq $a0, $t1, respond_to_W

      li $t1, 0x70          # 'p'
      beq $a0, $t1, respond_to_P
  
      j restore_stack       # Unhandled key, just return
  
      respond_to_Q:
          li $v0, 10
          syscall
      
      respond_to_A:
        # Play left movement sound
          li $a0, 60           # Pitch (middle C)
          li $a1, 1         # Duration in ms
          li $a2, 1            # Instrument (Piano)
          li $a3, 80           # Volume
          li $v0, 33
          syscall
          
          jal Is_Blocked_Left
          bne $v0, $zero, restore_stack
          li $a0, 0             # Move Left
          jal Move_Pill
          j restore_stack
      
      respond_to_D:
           # Play right movement sound
          li $a0, 64           # Pitch (E)
          li $a1, 1          # Duration in ms
          li $a2, 1            # Instrument (Piano)
          li $a3, 80           # Volume
          li $v0, 33
          syscall
          
          jal Is_Blocked_Right
          bne $v0, $zero, restore_stack
          li $a0, 1             # Move Right
          jal Move_Pill
          j restore_stack
      
      respond_to_S:
          # Play down movement sound
          li $a0, 55           # Pitch (G below middle C)
          li $a1, 1          # Duration in ms
          li $a2, 1            # Instrument (Piano)
          li $a3, 80           # Volume
          li $v0, 33
          syscall
          
          jal Is_Blocked_Down
          li $a0, 2             # Move Down
          jal Move_Pill
          j restore_stack
      
      respond_to_W:
          # Play rotation sound
          li $a0, 72           # Pitch (High C)
          li $a1, 1           # Duration in ms
          li $a2, 1            # Instrument (Piano)
          li $a3, 80           # Volume
          li $v0, 33
          syscall
          
          jal get_orientation
          bne $v0, $zero, vertical_condition
          j finish_rotation_check

          vertical_condition:
              jal Is_Blocked_Right
              bne $v0, $zero, restore_stack
              j finish_rotation_check
              
          finish_rotation_check:
              jal Is_Blocked_Down
              li $a0, 2             # Move Down
              
              jal Rotate_Pill
              j restore_stack

      respond_to_P:
            jal draw_paused_sign
            pause_loop:
              #li $a1, 55 #Xfor draw_paused_sign
              #li $a2, 20 #yfor draw_paused_sign
              #jal draw_paused_sign
              li $v0, 32  # pause the game
              li $a0, 100
              syscall
            
              la  $t0, ADDR_KBRD #load key
              lw  $t0, 0($t0)
              lw  $t1, 0($t0) 
              beq $t1, $zero, pause_loop  # if no key pressed, stay in loop
            
              lw  $t2, 4($t0) # get key ASCII
              li  $t3, 0x70# ASCII for p
              #jal drop_paused_sign
              bne $t2, $t3, pause_loop# if pressed key is not p, loop again
              jal erase_paused_sign
            
              # Resume game
              j game_loop            
              
      restore_stack:
          lw $ra, 4($sp)
          lw $a0, 0($sp)
          addi $sp, $sp, 8
          jr $ra
      
  Handle_Input:
            addi $sp, $sp, -4               # Save space on stack
            sw $ra, 0($sp)                  # Save return address
            
            la $t0, ADDR_KBRD           # $t0 = pointer to 0xffff0000
            lw $t0, 0($t0)              # $t0 now holds 0xffff0000
        
            lw $t1, 0($t0)
            beq $t1, $zero, no_key_pressed
        
            lw $a0, 4($t0)              # Read ASCII code from KEY_CODE
            jal keyboard_input          # Call handler
        
            no_key_pressed:
                lw $ra, 0($sp)        # Restore return address
                addi $sp, $sp, 4      # Restore stack
                jr $ra                # Correctly return
                
  Apply_Gravity_Pill:
      addi $sp, $sp, -24         # Allocate stack space for storing registers and variables
      sw $ra, 20($sp)            # Save return address

      la $a0, gravity_counter     # Load gravity counter
      lw $a1, 0($a0)             # Load counter value
      sw $a1, 0($sp)             # Save counter value to stack
      
      la $a2, gravity_threshold   # Load gravity threshold
      lw $a3, 0($a2)             # Load threshold value
      sw $a3, 4($sp)             # Save threshold value to stack
      
      # Compare counter with threshold
      bge $a1, $a3, trigger_gravity  # If counter >= threshold, trigger gravity
      
      # Increment gravity counter by gravity_increment
      la $a2, gravity_increment
      lw $a3, 0($a2)
      lw $a1, 0($sp)
      add $a1, $a1, $a3
      sw $a1, 0($sp)             # Update counter value on the stack
      sw $a1, 0($a0)             # Save updated counter to gravity_counter memory

      j restore_gravity_stack
  
      trigger_gravity:
            # Gravity triggers! Move pill down
            li $a0, 2                  # Direction: move down
            jal Move_Pill              # Call move function
      
            # Reset gravity counter
            la $a0, gravity_counter
            li $a1, 0                  
            sw $a1, 0($sp)             # Save reset counter to stack
            sw $a1, 0($a0)             # Save reset counter to gravity_counter memory
      
            # Accelerate gravity over time
            jal Accelerate_Gravity
      
            j restore_gravity_stack           # Ensure proper cleanup and return
        
      restore_gravity_stack:
            lw $ra, 20($sp)            # Restore return address
            addi $sp, $sp, 24          # Free stack space
            jr $ra                     # Return


# RECTANGLE
  Hor_L:
    add $t5, $zero, $zero
    Hloop:
      sw $t1, 0($t0)          # Paint pixel with gray color
      addi $t0, $t0, 4       # Move right (4 bytes per pixel)
      addi $t5, $t5, 1        # Increment counter
      slt $t6, $t5, $a0       # Check if counter < width
      bne $t6, $zero, Hloop
    jr $ra 
  
  Ver_L:
    add $t5, $zero, $zero
    Vloop:
      sw $t1, 0($t0)          # Paint pixel with gray color
      addi $t0, $t0, 256       # Move right (4 bytes per pixel)
      addi $t5, $t5, 1        # Increment counter
      slt $t6, $t5, $a1       # Check if counter < width
      bne $t6, $zero, Vloop
    jr $ra 
  
  Rand_color: # generates R,G,Y randomly.
    li $a0, 0  # Type of generator 
    li $a1, 3  # Upper bound (3 values: 0,1,2)
    li $v0, 42 # Syscall for random number
    syscall 
  
    la $t1, color_palette # Load address of color palette
    
    sll $t0, $a0, 2 # shifting left by two equal multiplication by 4
    add $t1, $t1, $t0 # change address to point to correct color
  
    lw $v0, 0($t1) # set return value as the color 
    jr $ra         # return with color in $v0

  draw_map:
    addi $sp, $sp, -16
    sw $ra, 0($sp)
    sw $s0, 4($sp)
    sw $s1, 8($sp)
    sw $s2, 12($sp)
    
    # Load map dimensions
    addi $a0, $zero, 20     # map width
    addi $a1, $zero, 25     # map height
    sw $a0, map_width
    sw $a1, map_height
    
    # Color initialization
    li $t1, 0x808080        # Grey color for walls
    li $t2, 0x000000        # Black color for entrance
    
    # Draw top border
    lw $t0, displayAddress  # Base display address
    la $t7, X_L
    lw $t8, 0($t7)          # X position
    la $t7, Y_L
    lw $t9, 0($t7)          # Y position
    sll $t8, $t8, 2         # Convert X to bytes (4 bytes per pixel)
    sll $t9, $t9, 8         # Convert Y to offset (256 bytes per row for 64-pixel width)
    add $t0, $t0, $t8       # Position X
    add $t0, $t0, $t9       # Position Y
    jal Hor_L               # Call horizontal line function
    
    # Draw bottom border
    lw $t0, displayAddress
    lw $t8, X_L
    lw $t9, Y_L
    add $t9, $t9, $a1       # Add height to Y for bottom border
    sll $t8, $t8, 2
    sll $t9, $t9, 8
    add $t0, $t0, $t8
    add $t0, $t0, $t9
    jal Hor_L               # Call horizontal line function
    
    # Draw bottle opening (entrance at top)
    lw $t0, displayAddress
    lw $t8, X_L
    lw $t9, Y_L
    srl $t6, $a0, 1         # Divide width by 2 to center opening
    add $t8, $t8, $t6
    addi $t8, $t8, -2       # Adjust position for centering
    sll $t8, $t8, 2
    sll $t9, $t9, 8
    add $t0, $t0, $t8
    add $t0, $t0, $t9
    
    # Draw the 4-unit wide opening in black
    sw $t2, 0($t0)          # Draw black pixel for entrance
    move $s0, $t0           # Save position for reference
    sw $t2, 4($t0)
    sw $t2, 8($t0)
    sw $t2, 12($t0)
    move $s1, $t0           # Save position
    
    # Draw grey borders around bottle entrance
    li $t3, 0x808080        # Grey color
    
    # Add border details to entrance - both sides
    addi $t4, $s1, 0
    sw $t3, 0($t4)          # Right side
    addi $t4, $s1, -256
    sw $t3, 0($t4)          # Up from right
    addi $t4, $s1, -256
    sw $t3, 16($t4)         # Up from left
    
    # Draw left vertical border
    lw $t0, displayAddress
    lw $t8, X_L
    lw $t9, Y_L
    sll $t8, $t8, 2
    sll $t9, $t9, 8
    add $t0, $t0, $t8
    add $t0, $t0, $t9
    jal Ver_L               # Call vertical line function
    
    # Draw right vertical border
    lw $t0, displayAddress
    lw $t8, X_L
    lw $t9, Y_L
    add $t8, $t8, $a0       # Add width to X for right border
    sll $t8, $t8, 2
    sll $t9, $t9, 8
    add $t0, $t0, $t8
    add $t0, $t0, $t9
    jal Ver_L               # Call vertical line function
    sw $t1, 0($t0)
    
    # Restore return address and registers
    lw $ra, 0($sp)
    lw $s0, 4($sp)
    lw $s1, 8($sp)
    lw $s2, 12($sp)
    addi $sp, $sp, 16
    jr $ra

  erase_rectangle:
    addi $sp, $sp, -4
    sw $ra, 0($sp)
    
    # Load base coordinates
    la $t7, X_L
    lw $t8, 0($t7)
    la $t7, Y_L
    lw $t9, 0($t7)
    addi $t8, $t8, -1 
    addi $t9, $t9, -1 
    
    li $t2, 0x000000       
    li $s0, 30        
    li $s1, 30         
    
    # Initialize row counter
    li $s2, 0               
    
    erase_row:
    beq $s2, $s1, erase_done
        
    lw $t0, displayAddress
    add $t3, $t8, 0        
    add $t4, $t9, $s2      
    sll $t3, $t3, 2 
    sll $t4, $t4, 8         
    add $t0, $t0, $t3    
    add $t0, $t0, $t4    
        
    # Initialize column counter
    li $s3, 0               # Current column
        
    erase_pixel:
        # Check if we've done all columns in this row
        beq $s3, $s0, next_row
        
        # Erase (make black) current pixel
        sw $t2, 0($t0)
        
        # Move to next pixel in row
        addi $t0, $t0, 4        # Move right (4 bytes per pixel)
        addi $s3, $s3, 1        # Increment column counter
        j erase_pixel
        
    next_row:
        # Move to next row
        addi $s2, $s2, 1 # Increment row counter
        j erase_row
        
    erase_done:
        # Restore return address
        lw $ra, 0($sp)
        addi $sp, $sp, 4
        jr $ra
        
  
#OBJECT PILL

  Spawn_In_Box: # Spawns the pill inside the box
        addi $sp, $sp, -4
        sw $ra, 0($sp)
        
        lw $a0, Y_L # t2 = Y offset X_1
        lw $a1, X_L # t3 = X offset##################  Y_1
    
        lw $t0, map_width # t0 = map width
        srl $t1, $t0, 1 # t1 = map_width / 2
        addi $t1, $t1, -1 # t1 = center - 1 (for left cell of pill)
    
        add  $a1, $a0, $t1 # Y1 = Y_L + (map_width / 2) - 1
    
        jal Spawn_pill
    
        lw $ra, 0($sp)
        addi $sp, $sp 4
        jr $ra

  Spawn_pill: # Helps spawning pills
    # Input:  $a0 = row, $a1 = col
    # Output: Pill intialized
  
    addi $sp, $sp, -32  # Make space for 6 values on stack
    sw   $ra, 28($sp)    # Store return address
    sw   $a0, 0($sp)     # Store X1
    sw   $a1, 4($sp)     # Store Y1
  
    sw $a0, 8($sp)       # Store X2
    addi $t0, $a1, 1     # Y2 = Y1 + 1 (Right block)
    sw $t0, 12($sp)      # Store Y2 (Same row)
      
      
    # Get first pill color
    jal Rand_color  
    sw $v0, 16($sp)      # Store C1 (Left block)
  
    # Get second pill color
    jal Rand_color  
    sw $v0, 20($sp)      # Store C2 (Right block)
  
    li $t0, 0            # Store Orientation
    sw $t0, 24($sp)
  
    # Call setter functions (reset $a0 before each call)
    lw $a0, 0($sp)
    jal set_x1   
  
    lw $a0, 4($sp)
    jal set_y1  
      
    lw $a0, 8($sp)
    jal set_x2 
  
    lw $a0, 12($sp)
    jal set_y2
  
    lw $a0, 16($sp)
    jal set_c1
  
    lw $a0, 20($sp)
    jal set_c2
  
    lw $a0, 24($sp)
    jal set_orientation

    li $a0, 0
    jal Set_Blocked_Up
    jal Set_Blocked_Right
    jal Set_Blocked_Down
    jal Set_Blocked_Left
  
    # Restore $ra and free stack space
    lw   $ra, 28($sp)    # Restore return address
    addi $sp, $sp, 32  # Free stack space
  
    jr $ra   # Return
  
  Draw_pill: # helps draw pills
  
      # Input:  
      #   Uses getter functions to fetch the pill's properties:
      #   - (X1, Y1): Coordinates of first cell  
      #   - (X2, Y2): Coordinates of second cell  
      #   - C1: Color of first cell  
      #   - C2: Color of second cell  
      #
      # Output:
      #   Calls Set_Pixel twice to draw the pill on the bitmap.
      #   No return value.
  
      addi $sp, $sp, -28
      sw $ra, 24($sp)
    
      jal get_x1
      sw $v0, 0($sp) # X1
    
      jal get_y1
      sw $v0, 4($sp) # Y1
    
      jal get_x2
      sw $v0, 8($sp) # X2
    
      jal get_y2
      sw $v0, 12($sp) # Y2
    
      jal get_c1
      sw $v0, 16($sp) # C1
    
      jal get_c2
      sw $v0, 20($sp) # C2
    
      lw $a0, 0($sp)  # Load X1 (row)
      lw $a1, 4($sp)  # Load Y1 (col)
      lw $a2, 16($sp) # Load C1 
      jal Set_Pixel
  
      lw $a0, 8($sp)  # Load X2 (row)
      lw $a1, 12($sp) # Load Y2 (col)
      lw $a2, 20($sp) # Load C2 
      jal Set_Pixel 
  
      #Restore stack and return
      lw $ra, 24($sp) # Restore return address
      addi $sp, $sp, 28 # Free stack .space
      jr  $ra 
  
  Erase_Pill: # Erases the pill
      addi $sp, $sp, -24      # Allocate stack space
      sw $ra, 20($sp)         # Save return address
    
      jal get_x1
      sw $v0, 0($sp)          # Store X1
    
      jal get_y1
      sw $v0, 4($sp)          # Store Y1
    
      jal get_x2
      sw $v0, 8($sp)          # Store X2
    
      jal get_y2
      sw $v0, 12($sp)         # Store Y2
  
      # Erase first pixel
      lw $a0, 0($sp)          # Load X1 (row)
      lw $a1, 4($sp)          # Load Y1 (col)
      jal Kill_Pixel          # Erase first cell
  
      # Erase second pixel
      lw $a0, 8($sp)          # Load X2 (row)
      lw $a1, 12($sp)         # Load Y2 (col)
      jal Kill_Pixel          # Erase second cell
  
      # Restore stack and return
      lw $ra, 20($sp)         # Restore return address
      addi $sp, $sp, 24       # Free stack space
      jr  $ra
       
  Move_Pill: # Moves pill (0 = Left, 1 = Right, 2 = Down)
      # Input:
      #    a0 -> direction (0 = Left, 1 = Right, 2 = Down)
      # Return:
      #    None ( shift the pill down)
  
      addi $sp, $sp, -24   # Allocate stack space
      sw $ra, 20($sp)      # Save return address
      sw $a0, 0($sp)      # Save direction
      
      # Fetch X1, Y1
      jal get_x1
      sw $v0, 4($sp)
      jal get_y1
      sw $v0, 8($sp)
  
      # Fetch X2, Y2
      jal get_x2
      sw $v0, 12($sp)
      jal get_y2
      sw $v0, 16($sp)
  
      # Erase both pixels before moving
      lw $a0, 4($sp)
      lw $a1, 8($sp)
      jal Kill_Pixel
  
      lw $a0, 12($sp)
      lw $a1, 16($sp)
      jal Kill_Pixel
  
      # Restore direction and determine movement
      lw $a0, 0($sp)          # Load direction
      beq $a0, 0, move_pill_left   # If direction == 0, move left
      beq $a0, 1, move_pill_right  # If direction == 1, move right
      beq $a0, 2, move_pill_down   # If direction == 2, move down
      
      j draw_pixels              # Safety check
  
      move_pill_left:
          lw $a0, 8($sp)          # Load Y1
          addi $a0, $a0, -1       # Y1 = Y1 - 1
          jal set_y1              # Update stored Y1 in pill structure
      
          lw $a0, 16($sp)         # Load Y2
          addi $a0, $a0, -1       # Y2 = Y2 - 1
          jal set_y2              # Update stored Y2 in pill structure
      
          j draw_pixels
  
      move_pill_right:
          lw $a0, 8($sp)          # Load Y1
          addi $a0, $a0, 1        # Y1 = Y1 + 1
          jal set_y1              # Update stored Y1 in pill structure
  
          lw $a0, 16($sp)         # Load Y2
          addi $a0, $a0, 1        # Y2 = Y2 + 1
          jal set_y2              # Update stored Y2 in pill structure
  
          j draw_pixels
  
      move_pill_down:
    
          lw $a0, 4($sp)          # Load X1
          addi $a0, $a0, 1        # X1 = X1 + 1
          jal set_x1              # Update stored X1 in pill structure
      
          lw $a0, 12($sp)         # Load X2
          addi $a0, $a0, 1        # X2 = X2 + 1
          jal set_x2              # Update stored X2 in pill structure
      
          j draw_pixels
          
      draw_pixels:
          
          jal Draw_pill
    
          lw $ra, 20($sp)         # Restore return address
          addi $sp, $sp, 24       # Free stack space
          jr $ra
  
  Rotate_Pill: # Rotates pill clock wise once
      # Input:
      #    None ( Because the things we need are stored in our object pill)
      # Return:
      #    None ( shift the pill down)
      addi $sp, $sp, -32
      sw $ra, 28($sp)
  
      jal get_x1
      sw $v0, 0($sp)
  
      jal get_y1
      sw $v0, 4($sp)
  
      jal get_x2
      sw $v0, 8($sp)
  
      jal get_y2
      sw $v0, 12($sp)
  
      jal get_c1
      sw $v0, 16($sp)
  
      jal get_c2
      sw $v0, 20($sp)
  
      jal get_orientation
      sw $v0, 24($sp)
  
      lw $a0, 24($sp)
      
      beq $a0, 0, rotate_vertical
      beq $a0, 1, rotate_horizontal
      j redraw_rotated_pill
  
      rotate_vertical:
          lw $s0, 0($sp)    # X1
          lw $s1, 4($sp)    # Y1
          lw $s2, 8($sp)    # X2
          lw $s3, 12($sp)   # Y2
          
          move $a0, $s2     # Erase old pixel
          move $a1, $s3
          jal Kill_Pixel
  
          addi $s2, $s0, 1  # X2 = X1 + 1
          move $s3, $s1     # Y2 = Y1
  
          move $a0 , $s2
          jal set_x2
  
          move $a0, $s3
          jal set_y2
  
          li $a0, 1
          jal set_orientation
  
          j redraw_rotated_pill
  
      rotate_horizontal:
          lw $s0, 0($sp)    # X1
          lw $s1, 4($sp)    # Y1
          lw $s2, 8($sp)    # X2
          lw $s3, 12($sp)   # Y2
  
          move $a0, $s2     # Erase old pixel 
          move $a1, $s3
          jal Kill_Pixel
          
          move $s2, $s0     # X2 = X1
          addi $s3, $s1, 1  # Y2 = Y1 +  1
  
          lw $s0, 16($sp)   # C1
          lw $s1, 20($sp)   # C2
  
          move $a0, $s0     
          jal set_c2        # C2 = C1
  
          move $a0, $s1  
          jal set_c1        # C1 = C2
  
          move $a0 , $s2
          jal set_x2
  
          move $a0, $s3
          jal set_y2
  
          li $a0, 0
          jal set_orientation
  
          j redraw_rotated_pill
   
      redraw_rotated_pill:
          jal Draw_pill
          lw $ra, 28($sp)   # Restore return address
          addi $sp, $sp, 32 # Restore stack pointer
          jr $ra

          
# Getter methods for pill values



  get_x1: # get value X1
    la $t0 active_pill # Load base address
    lw $v0, 0($t0)     # Load X1 value
    jr   $ra           # Return
  
  get_y1: # get value Y1
    la   $t0, active_pill
    lw   $v0, 4($t0)       # Load Y1 value
    jr   $ra
    
  get_x2: # get value X2
    la   $t0, active_pill
    lw   $v0, 8($t0)
    jr   $ra
    
  get_y2: # get value Y2
    la   $t0, active_pill
    lw   $v0, 12($t0)
    jr   $ra
    
  get_c1: # get value C1
    la   $t0, active_pill
    lw   $v0, 16($t0)
    jr   $ra
  
  get_c2: # get value C2
    la   $t0, active_pill
    lw   $v0, 20($t0)
    jr   $ra
  
  get_orientation: # get orientation
    la   $t0, active_pill
    lw   $v0, 24($t0)
    jr   $ra
    

# Setter methods for the pill values

  set_x1: # set value X1
    la   $t0, active_pill
    sw   $a0, 0($t0) 
    jr   $ra 
  
  set_y1: # set value Y1
    la   $t0, active_pill
    sw   $a0, 4($t0) 
    jr   $ra 
   
  set_x2: # set value X2
    la   $t0, active_pill
    sw   $a0, 8($t0) 
    jr   $ra 
  
  set_y2: # set value Y2
    la   $t0, active_pill
    sw   $a0, 12($t0) 
    jr   $ra 
  
  set_c1: # set value C1
    la   $t0, active_pill
    sw   $a0, 16($t0) 
    jr   $ra 
    
  set_c2: # set value C2
    la   $t0, active_pill
    sw   $a0, 20($t0) 
    jr   $ra  
  
  set_orientation: # set orientation
    la   $t0, active_pill
    sw   $a0, 24($t0)
    jr   $ra
    

# Getter  and Setter function for collisons

  Is_Blocked_Up:
      la $t0, collision_map   # Load base address
      lw $v0, 0($t0)          # Load 'Up' value (0 = free, 1 = blocked)
      jr $ra                  # Return (value is in $v0)
  
  Set_Blocked_Up: # Sets 'Up' collision (0 = free, 1 = blocked)
      la $t0, collision_map   # Load base address
      sw $a0, 0($t0)          # Store value at 'Up' position
      jr $ra                                  # Return
  
  Is_Blocked_Down:
      la $t0, collision_map   
      lw $v0, 4($t0)          # Load 'Down' value
      jr $ra                  
  
  Set_Blocked_Down:
      la $t0, collision_map   
      sw $a0, 4($t0)          # Store value at 'Down' position
      jr $ra           
  
  Is_Blocked_Left:
      la $t0, collision_map   
      lw $v0, 8($t0)          # Load 'Left' value
      jr $ra                  
  
  Set_Blocked_Left:
      la $t0, collision_map   
      sw $a0, 8($t0)          # Store value at 'Left' position
      jr $ra         
  
  Is_Blocked_Right:
      la $t0, collision_map   
      lw $v0, 12($t0)         # Load 'Right' value
      jr $ra                  
  
  Set_Blocked_Right:
      la $t0, collision_map   
      sw $a0, 12($t0)         # Store value at 'Right' position
      jr $ra        
      

# Map travesal 

  Grid_To_Bitmap: # helps traverse easily in bitmap using grid representation
      # Input:   $a0 = row, $a1 = col
      # Outputt: $v0 = bitmap address
  
      lw $t0, displayAddress # Load base address of bitmap memory
      li $t1, 256            # Row shift val 
      li $t2, 4              # Column shift val
  
      mul $t3, $a0, $t1      # row * 128 (vertical shift)
      mul $t4, $a1, $t2      # col * 4 (horizontal shift)
  
      add $t5, $t3, $t4      # Offset = row_shift + col_shift
      add $v0, $t0, $t5      # Final address = base + offset
  
      jr $ra
  
  Bitmap_To_Grid: # helps reverse egineer grid values 
      # Input: #a0 = bitmap address
      # Output: $v0 = row, $v1 = col
  
      lw $t0 displayAddress # load base address of bitmap memory
      sub $t1, $a0, $t0     # $t1 =  $a0 - $t0 (Offset from base)
      li $t2, 256           # shift down moves 128 per row
  
      div $t1, $t2          # Divide offset by 128 
      mflo $v1              # Row = quotient 
      mfhi $t3              # Remainder = leftover colums offset
  
      li $t4, 4            # Shift right moves 4 per column
      div $t3, $t4          # Divide remainder by 4
      mflo $v1              # Column = quotient
  
      jr $ra
  
  Set_Pixel: # set color at row and column
      # Input:  
      #   $a0 = row (X-coordinate in grid)  
      #   $a1 = col (Y-coordinate in grid)  
      #   $a2 = color (value to set the pixel)
      #
      # Output:
      #   Updates the pixel at (row, col) in the bitmap with color $a2.
      #   No return value.
    
      addi $sp, $sp, -12 # Allocate space on stack
      sw $ra, 8($sp)     # Save return address
      sw $a2, 4($sp)     # Save color
    
      jal Grid_To_Bitmap # Convert (row, col) to bitmap address
  
      
      lw $a2, 4($sp)     # Load color
      sw $a2, 0($v0)     # Paint pixel at computed displayAddress
    
      lw $ra, 8($sp)
      addi $sp, $sp, 12 
      jr $ra
  
  Kill_Pixel: # set Black at row and column
      # Input:  
      #   - $a0 = row (X coordinate)
      #   - $a1 = col (Y coordinate)
      #
      # Output:
      #   - Erases the pixel at (row, col) by setting its color to black (0)
      #   - No return value
  
      addi $sp, $sp, -8       # Allocate stack space
      sw $ra, 4($sp)          # Save return address
  
      li $a2, 0               # Load black color (0)
      jal Set_Pixel           # Call Set_Pixel to erase the pixel
  
      lw $ra, 4($sp)          # Restore return address
      addi $sp, $sp, 8        # Free stack space
      jr $ra                  # Return
  
  Get_Color: # retrieve color at row and column
      # Input:
      #    a0 -> X (row)
      #    a1 -> Y (colum)
      # 
      # Return:
      #    v0 -> color (moves the cell actually on the bitmap)
  
      addi $sp, $sp, -16  # Allocate stack space
      sw $ra, 12($sp)     # Save return address
      sw $a0, 0($sp)      # Save X (row)
      sw $a1, 4($sp)      # Save Y (column)
      
      jal Grid_To_Bitmap  # Convert (X, Y) to bitmap address
  
      lw $v0, 0($v0)      # Load color from memory (the color stored at that pixel)
  
      lw $ra, 12($sp)     # Restore return address
      addi $sp, $sp, 16   # Free stack space
      jr $ra              # Return
      
  Move_Cell:
      # Input:
      #    a0 -> X (row)
      #    a1 -> Y (colum)
      #    a2 -> direction (0 -> Move left, 1 -> Move right, 2 -> Mover down)
      # Return:
      #    None (moves the cell down actually on the bitmap)
  
      addi $sp, $sp, -20      # Allocate stack space
      sw $ra, 16($sp)         # Save return address
      sw $a0, 0($sp)          # Save X
      sw $a1, 4($sp)          # Save Y
      sw $a2, 8($sp)          # Save direction
  
      # Get the current color of the pixel
      jal Get_Color
      sw $v0, 12($sp)          # Store the color
  
      #Erase the pixel
      jal Kill_Pixel
  
      # Update the position based on direction
      lw $a2, 8($sp)
      beq $a2, 0, move_left    # If direction == 0, move left
      beq $a2, 1, move_right   # If direction == 1, move right
      beq $a2, 2, move_down    # If direction == 2, move down
      j draw_pixel             # Default case (shouldn't happen, but safe)
  
      move_left:
          lw $a1, 4($sp)          # Load Y
          addi $a1, $a1, -1       # Y = Y - 1
          j draw_pixel
      
      move_right:
          lw $a1, 4($sp)          # Load Y
          addi $a1, $a1, 1        # Y = Y + 1
          j draw_pixel
      
      move_down:
          lw $a0, 0($sp)          # Load X
          addi $a0, $a0, 1        # X = X + 1
          j draw_pixel            
          
      draw_pixel:
          lw $a2, 12($sp)          # Load color
          jal Set_Pixel           # Paint at new location
      
          # Restore stack and return
          lw $ra, 16($sp)         # Restore return address
          addi $sp, $sp, 20       # Free stack space
          jr $ra
  
          

 #OBJECT GERMS
 

# Germ Object

  Spawn_germ:
      addi $sp, $sp, -28     
      sw $ra, 24($sp)
  
  redraw:
      lw $t6, map_height #load dim
      lw $t7, map_width
      lw $t8, Y_L         # t8 = left edge
  
      li $v0, 42 # Generate infected area row: Y_L + height/2 + height/2
      li $a0, 0
      srl $a1, $t6, 1 # a1 = height/2
      syscall
      srl $t9, $t6, 1 # t9 = height/2
      add $t0, $t9, $a0 # t0 = height/2 + height/2
      add $t0, $t0, $t8# t0 = Y_L + offset
      sw  $t0, 0($sp) 
  
      li $v0, 42 # nfected area colum: col = Y_L + 1 + (width - 1)
      li $a0, 0
      addi $a1, $t7, -1 # width - 1
      syscall
      addi $t1, $t8, 1
      add $t1, $t1, $a0 # Final col
      sw $t1, 4($sp)
  
      move $a0, $t0
      move $a1, $t1
      jal Grid_To_Bitmap
      move $t2, $v0
  
      lw $t3, 0($t2)        # check if duplicates
      li $t4, 0x000000
      bne $t3, $t4, redraw  # retry if not black
  
      jal Rand_color           # $v0 = original color
      move $t5, $v0            # Copy to $t5 as default
      
      li $t0, 0x0000FF # Check if blue
      beq $v0, $t0, make_light_blue
      
      li $t0, 0xFF0000 # Check if red
      beq $v0, $t0, make_pink
      
      li $t0, 0xFFFF00 # Check if yellow 
      beq $v0, $t0, make_light_yellow
      
      j done_color
  
      make_light_blue:
          li $t5, 0x8080FF
          j done_color
      
      make_pink:
          li $t5, 0xFF8080
          j done_color
      
      make_light_yellow:
          li $t5, 0xFFFF99
          j done_color
      
      done_color:
      
          lw $a0, 0($sp)       # row
          lw $a1, 4($sp)       # col
          move $a2, $t5
          jal Set_Pixel
      
          lw $ra, 24($sp)
          addi $sp, $sp, 28
          jr $ra
          

# Collison Handling 

   Detect_Collison:
      addi $sp, $sp, -24  # Allocate stack space
      sw $ra, 20($sp)     # Save return address

      jal get_x1          # Load X1
      move $t0, $v0
      sw $v0, 0($sp)
      
      jal get_y1          # Load Y1
      move $t1, $v0
      sw $v0, 4($sp)
      
      jal get_x2          # Load X2
      move $t2, $v0
      sw $v0, 8($sp)
      
      jal get_y2          # Load Y2
      move $t3, $v0
      sw $v0, 12($sp)
      
      jal get_orientation # Load Orientation (0 = Horizontal, 1 = Vertical)
      move $t5, $v0
      sw $v0, 16($sp)

      # Reset collision map (all free initially)
      li $a0, 0
      jal Set_Blocked_Up
      jal Set_Blocked_Down
      jal Set_Blocked_Left
      jal Set_Blocked_Right
      
      # ---- Checking Surroundings ----
      bne $t5, 1, Check_Down_Horizontal  # If Horizontal
      j Check_Down_Vertical # If Vertical

      Check_Down_Vertical:
          jal Set_Collison_Values 
        
          addi $a0, $t2, 1  # X2 + 1 (below second pill part)
          move  $a1, $t3    # Y2
          jal Get_Color
          li $a0, 1
          beq   $v0, $zero, Check_Up_Vertical
          jal Set_Blocked_Down

          j Check_Up_Vertical

      Check_Up_Vertical:
          jal Set_Collison_Values
          
          addi $a0, $t0, -1 
          move $a1, $t1
          jal Get_Color
          li $a0, 1
          beq   $v0, $zero, Check_Left_Vertical
          jal Set_Blocked_Up
        
          j Check_Left_Vertical

      Check_Left_Vertical:
          jal Set_Collison_Values 
          
          move $a0, $t0
          addi $a1, $t1, -1
          jal Get_Color
          li $a0, 1
          beq   $v0, $zero,  check_second_cell_left
          jal Set_Blocked_Left

          j Check_Rigth_Vertical

          check_second_cell_left:
              jal Set_Collison_Values
              
              move $a0, $t2
              addi $a1, $t3, -1
              jal Get_Color
              li $a0, 1
              beq   $v0, $zero,  Check_Rigth_Vertical
              jal Set_Blocked_Left 

              j Check_Rigth_Vertical

      Check_Rigth_Vertical:
          jal Set_Collison_Values
 
          move $a0, $t0
          addi $a1, $t1, 1
          jal Get_Color
          li $a0, 1
          beq   $v0, $zero, check_second_cell_right
          jal Set_Blocked_Right

          j Complete_Collision_Check 

          check_second_cell_right:
              jal Set_Collison_Values
              
              move $a0, $t2
              addi $a1, $t3, 1
              jal Get_Color
              li $a0, 1
              beq   $v0, $zero, Complete_Collision_Check 
              jal Set_Blocked_Right

              j Complete_Collision_Check
          
          
              
      Check_Down_Horizontal:
          jal Set_Collison_Values 
        
          addi $a0, $t0, 1
          move $a1, $t1
          jal Get_Color
          li $a0, 1
          beq   $v0, $zero, check_second_cell_down
          jal Set_Blocked_Down
          
          j Check_Up_Horizontal

          check_second_cell_down:
              jal Set_Collison_Values  
              
              addi $a0, $t2, 1
              move $a1, $t3
              jal Get_Color
              li $a0, 1 
              beq   $v0, $zero, Check_Up_Horizontal
              jal Set_Blocked_Down

              j Check_Up_Horizontal
             
      Check_Up_Horizontal:
          jal Set_Collison_Values 
        
          addi $a0, $t0, -1
          move $a1, $t1
          jal Get_Color
          li $a0, 1
          beq   $v0, $zero, check_second_cell_up
          jal Set_Blocked_Up
          
          j Check_Left_Horizontal

          check_second_cell_up:
              jal Set_Collison_Values 
              
              addi $a0, $t2, -1
              move $a1, $t3
              jal Get_Color
              li $a0, 1 
              beq   $v0, $zero, Check_Left_Horizontal
              jal Set_Blocked_Up

              j Check_Left_Horizontal       

      Check_Left_Horizontal:
          jal Set_Collison_Values 
         
          move $a0, $t0
          addi $a1, $t1, -1
          jal Get_Color
          li $a0, 1
          beq   $v0, $zero, Check_Right_Horizontal
          jal Set_Blocked_Left

          j Check_Right_Horizontal

      Check_Right_Horizontal:
          jal Set_Collison_Values 
          
          move $a0, $t2
          addi $a1, $t3, 1
          jal Get_Color
          li $a0, 1
          beq   $v0, $zero, Complete_Collision_Check
          jal Set_Blocked_Right

          j Complete_Collision_Check
          
          
      Set_Collison_Values:
          lw $t0, 0($sp)
          lw $t1, 4($sp)
          lw $t2, 8($sp)
          lw $t3, 12($sp)
          lw $t4, 16($sp)
          jr $ra

      Complete_Collision_Check:
          lw $ra, 20($sp)
          addi $sp, $sp, 24
          jr $ra

   Handle_Collision:
      addi $sp, $sp, -4
      sw $ra, 0($sp)

      jal Is_Blocked_Down 
      bne $v0, $zero, blocked_down

      j End_Collison_Handling


      blocked_down: # complete this 
          jal check_for_matches
          jal Spawn_In_Box
          jal Draw_pill
          jal Detect_Collison
          la $t0, gravity_counter #rest the gravity counter
          li $t1, 0
          sw $t1, 0($t0)
          j End_Collison_Handling

      End_Collison_Handling:
          lw $ra, 0($sp)
          addi $sp, $sp, 4
          jr $ra 
          

# Pattern Operations and detection
  
  # Function to check for matches based on a landed pill
      check_for_matches:
          addi $sp, $sp, -36              # Allocate stack space
          sw $ra, 32($sp)                 # Save return address
          sw $s0, 28($sp)                 # Save preserved registers
          sw $s1, 24($sp)
          sw $s2, 20($sp)
          sw $s3, 16($sp)
          sw $s4, 12($sp)
          sw $s5, 8($sp)
          sw $s6, 4($sp)
          sw $s7, 0($sp)
          
          # Get orientation and pill info
          jal get_orientation             # Get pill orientation (0=horizontal, 1=vertical)
          move $s0, $v0                   # Save orientation
          
          jal get_x1
          move $s1, $v0                   # X coordinate of first half
          
          jal get_y1
          move $s2, $v0                   # Y coordinate of first half
          
          jal get_x2
          move $s3, $v0                   # X coordinate of second half
          
          jal get_y2
          move $s4, $v0                   # Y coordinate of second half
          
          jal get_c1
          move $s5, $v0                   # Color of first half
          
          jal get_c2
          move $s6, $v0                   # Color of second half
          
          li $s7, 0                       # Initialize match found flag
          
          # Branch based on pill orientation
          beq $s0, $zero, horizontal_pill_case
          j vertical_pill_case
          
        horizontal_pill_case:
            # For horizontal pill (side by side)
            # Check if left half is part of a horizontal match
            move $a0, $s1                   # X coordinate (row)
            move $a1, $s2                   # Y coordinate (column)
            move $a2, $s5                   # Color of left half
            jal check_horizontal_match
            or $s7, $s7, $v0                # Update match found flag
            
            # Check if right half is part of a horizontal match
            move $a0, $s3                   # X coordinate (row)
            move $a1, $s4                   # Y coordinate (column)
            move $a2, $s6                   # Color of right half
            jal check_horizontal_match
            or $s7, $s7, $v0                # Update match found flag
            
            # Check if left half is part of a vertical match
            move $a0, $s1                   # X coordinate (row)
            move $a1, $s2                   # Y coordinate (column)
            move $a2, $s5                   # Color of left half
            jal check_vertical_match
            or $s7, $s7, $v0                # Update match found flag
            
            # Check if right half is part of a vertical match
            move $a0, $s3                   # X coordinate (row)
            move $a1, $s4                   # Y coordinate (column)
            move $a2, $s6                   # Color of right half
            jal check_vertical_match
            or $s7, $s7, $v0                # Update match found flag
            
            j matches_checked
            
        vertical_pill_case:
            # For vertical pill (stacked)
            # Check if top half is part of a horizontal match
            move $a0, $s1                   # X1 coordinate (row)
            move $a1, $s2                   # Y1 coordinate (column)
            move $a2, $s5                   # Color of top half
            jal check_horizontal_match
            or $s7, $s7, $v0                # Update match found flag
            
            # Check if bottom half is part of a horizontal match
            move $a0, $s3                   # X2 coordinate (row)
            move $a1, $s4                   # Y2 coordinate (column)
            move $a2, $s6                   # Color of bottom half
            jal check_horizontal_match
            or $s7, $s7, $v0                # Update match found flag
            
            # Check if top half is part of a vertical match
            move $a0, $s1                   # X1 coordinate (row)
            move $a1, $s2                   # Y1 coordinate (column)
            move $a2, $s5                   # Color of top half
            jal check_vertical_match
            or $s7, $s7, $v0                # Update match found flag
            
            # Check if bottom half is part of a vertical match
            move $a0, $s3                   # X2 coordinate (row)
            move $a1, $s4                   # Y2 coordinate (column)
            move $a2, $s6                   # Color of bottom half
            jal check_vertical_match
            or $s7, $s7, $v0                # Update match found flag
            
            j matches_checked
            
        matches_checked:
            # If matches were found, apply gravity and check again
            beqz $s7, no_matches_found
            
            # Apply gravity to make floating blocks fall
            #jal apply_gravity
            
            # Check for new matches that might have formed
            jal check_for_matches
            
        no_matches_found:
            # Restore registers and return
            lw $s7, 0($sp)
            lw $s6, 4($sp)
            lw $s5, 8($sp)
            lw $s4, 12($sp)
            lw $s3, 16($sp)
            lw $s2, 20($sp)
            lw $s1, 24($sp)
            lw $s0, 28($sp)
            lw $ra, 32($sp)
            addi $sp, $sp, 36
            
            # Return match found flag
            move $v0, $s7
            jr $ra
      
  # Check for horizontal matches (4+ in a row)
      check_horizontal_match:
          # $a0 = row, $a1 = column, $a2 = color to match
          addi $sp, $sp, -36
          sw $a0, 32($sp)  #ogog row
          sw $a1, 28($sp)  #ogog col
          sw $ra, 24($sp)
          sw $a0, 20($sp)     # row
          sw $a1, 16($sp)     # column
          sw $a2, 12($sp)     # color
          sw $zero, 8($sp)    # match count left
          sw $zero, 4($sp)    # match count right
          sw $zero, 0($sp)    # match found flag
          
          # Count same-colored blocks to the left
          count_left:
              addi $t0, $a1, -1       # column - 1
              lw $t1, Y_L             # Get left edge
              blt $t0, $t1, done_left # Don't go past left edge
              
              move $a1, $t0           # Update column parameter
              jal Get_Color           # Get color at (row, column-1)
              
              move $t1, $v0           # Save color result
              lw $t2, 12($sp)         # Load target color
              
              # Check if colors match
              move $a0, $t1           # First color
              move $a1, $t2           # Second color
              jal CheckColor          # Check if colors match
              
              beqz $v0, done_left     # Stop if different color
              
              lw $t3, 8($sp)          # Load left match count
              addi $t3, $t3, 1        # Increment count
              sw $t3, 8($sp)          # Save updated count
              
              lw $a0, 20($sp)         # Restore row
              lw $a1, 16($sp)         # Original column
              addi $a1, $a1, -1       # Move left
              sw $a1, 16($sp)         # Update original column
              j count_left
          
          done_left:
              # Restore original parameters
              lw $a0, 32($sp)         # Restore row
              lw $a1, 28($sp)         # Restore column
              lw $a2, 12($sp)         # Restore color
              sw $a0, 20($sp)  #ogog row
              sw $a1, 16($sp)  #ogog col
          
          # Count same-colored blocks to the right
          count_right:
              addi $t0, $a1, 1        # column + 1
              lw $t1, map_width       # Get map width
              lw $t2, Y_L             # Get left edge
              add $t1, $t1, $t2       # Right boundary = left + width
              bge $t0, $t1, done_right  # Don't go past right edge
              
              move $a1, $t0           # Update column parameter
              jal Get_Color           # Get color at (row, column+1)
              
              move $t1, $v0           # Save color result
              lw $t2, 12($sp)         # Load target color
              
              # Check if colors match
              move $a0, $t1           # First color
              move $a1, $t2           # Second color
              jal CheckColor          # Check if colors match
              
              beqz $v0, done_right    # Stop if different color
              
              lw $t3, 4($sp)          # Load right match count
              addi $t3, $t3, 1        # Increment count
              sw $t3, 4($sp)          # Save updated count
              
              lw $a0, 20($sp)         # Restore row
              lw $a1, 16($sp)         # Original column
              addi $a1, $a1, 1        # Move right
              sw $a1, 16($sp)         # Update original column
              j count_right
          
          done_right:
              # Calculate total match count (including current block)
              # Restore original parameters
              lw $a0, 32($sp)         # Restore row
              lw $a1, 28($sp)         # Restore column
              sw $a0, 20($sp)  #ogog row
              sw $a1, 16($sp)  #ogog col
              
              lw $t0, 8($sp)          # Left matches
              lw $t1, 4($sp)          # Right matches
              addi $t0, $t0, 1        # Left + current block
              add $t0, $t0, $t1       # + right matches
              
              # Check if we have 4 or more consecutive blocks
              li $t2, 4
              blt $t0, $t2, horizontal_match_done
              
              # We found a match!
              li $t3, 1
              sw $t3, 0($sp)          # Set match found flag
              
              # Calculate leftmost position
              lw $t4, 16($sp)         # Original column
              lw $t5, 8($sp)          # Left count
              sub $t4, $t4, $t5       # Leftmost = column - left_count
              
              # Remove the line
              lw $a0, 20($sp)         # Row
              move $a1, $t4           # Leftmost column
              move $a2, $t0           # Length of match
              li $a3, 0               # Horizontal direction
              jal remove_match
          
          horizontal_match_done:
              # Return match found flag
              lw $v0, 0($sp)
              
              # Restore stack and return
              lw $ra, 24($sp)
              addi $sp, $sp, 36
              jr $ra
      
  # Check for vertical matches (4+ in a row)
      check_vertical_match:
          # $a0 = row, $a1 = column, $a2 = color to match
          addi $sp, $sp, -36
          sw $a0, 32($sp)     # og row
          sw $a1, 28($sp)     # og column
          sw $ra, 24($sp)
          sw $a0, 20($sp)     # row
          sw $a1, 16($sp)     # column
          sw $a2, 12($sp)     # color
          sw $zero, 8($sp)    # match count up
          sw $zero, 4($sp)    # match count down
          sw $zero, 0($sp)    # match found flag
          
          # Count same-colored blocks upward
          count_up:
              addi $t0, $a0, -1       # row - 1
              lw $t1, X_L             # Get top edge
              bge $t1, $t0, done_up   # Don't go past top edge
              
              move $a0, $t0           # Update row parameter
              jal Get_Color           # Get color at (row-1, column)
              
              move $t1, $v0           # Save color result
              lw $t2, 12($sp)         # Load target color
              
              # Check if colors match
              move $a0, $t1           # First color
              move $a1, $t2           # Second color
              jal CheckColor          # Check if colors match
              
              beqz $v0, done_up       # Stop if different color
              
              lw $t3, 8($sp)          # Load up match count
              addi $t3, $t3, 1        # Increment count
              sw $t3, 8($sp)          # Save updated count
              
              lw $a0, 20($sp)         # update cur row
              addi $a0, $a0, -1       # Move up
              sw $a0, 20($sp)         # Update cur row
              lw $a1, 16($sp)         # Restore column
              j count_up
          
          done_up:
              # Restore original parameters
              lw $a0, 32($sp)         # Restore row #
              lw $a1, 28($sp)         # Restore column
              lw $a2, 12($sp)         # Restore color
              sw $a0, 20($sp)
              sw $a1, 16($sp)
          
          # Count same-colored blocks downward
          count_down:
              addi $t0, $a0, 1        # row + 1
              lw $t1, map_height      # Get map height
              lw $t2, X_L             # Get top edge
              add $t1, $t1, $t2       # Bottom boundary = top + height
              bge $t0, $t1, done_down # Don't go past bottom edge
              
              move $a0, $t0           # Update row parameter
              jal Get_Color           # Get color at (row+1, column)
              
              move $t1, $v0           # Save color result
              lw $t2, 12($sp)         # Load target color
              
              # Check if colors match
              move $a0, $t1           # First color
              move $a1, $t2           # Second color
              jal CheckColor          # Check if colors match
              
              beqz $v0, done_down     # Stop if different color
              
              lw $t3, 4($sp)          # Load down match count
              addi $t3, $t3, 1        # Increment count
              sw $t3, 4($sp)          # Save updated count
              
              lw $a0, 20($sp)         # Original row
              addi $a0, $a0, 1        # Move down
              sw $a0, 20($sp)         # Update original row
              lw $a1, 16($sp)         # Restore column
              j count_down
          
          done_down:
      
              lw $a0, 32($sp)         # Restore row #
              lw $a1, 28($sp)         # Restore column
              sw $a0, 20($sp)
              sw $a1, 16($sp)
              # Calculate total match count (including current block)
              lw $t0, 8($sp)          # Up matches
              lw $t1, 4($sp)          # Down matches
              addi $t0, $t0, 1        # Up + current block
              add $t0, $t0, $t1       # + down matches
              
              # Check if we have 4 or more consecutive blocks
              li $t2, 4
              blt $t0, $t2, vertical_match_done
              
              # We found a match!
              li $t3, 1
              sw $t3, 0($sp)          # Set match found flag
              
              # Calculate topmost position
              lw $t4, 20($sp)         # Original row
              lw $t5, 8($sp)          # Up count
              sub $t4, $t4, $t5       # Topmost = row - up_count
              
              # Remove the line
              move $a0, $t4           # Topmost row
              lw $a1, 16($sp)         # Column
              move $a2, $t0           # Length of match
              li $a3, 1               # Vertical direction
              jal remove_match
          
          vertical_match_done:
              # Return match found flag
              lw $v0, 0($sp)
              
              # Restore stack and return
              lw $ra, 24($sp)
              addi $sp, $sp, 36
              jr $ra

      CheckColor:
        # Input:
        #   $a0 -> First color
        #   $a1 -> Second color
        # Output:
        #   $v0 -> 1 if colors match, 0 if not
        
        addi $sp, $sp, -12
        sw $ra, 8($sp)
        sw $a0, 4($sp)        # Save first color
        sw $a1, 0($sp)        # Save second color
        
        # If the colors are exactly the same, they match
        lw $t0, 4($sp)        # Load first color
        lw $t1, 0($sp)        # Load second color
        beq $t0, $t1, same_color
        
        # Check if first color is Red pill and second is Red virus
        lw $t2, Red           # Load Red pill color (0xff0000)
        lw $t3, V_Red         # Load Red virus color (0xFF8080)
        
        beq $t0, $t2, check_t1_red
        beq $t0, $t3, check_t1_red
        j check_blue
        
        check_t1_red:
            beq $t1, $t2, same_color
            beq $t1, $t3, same_color
            j different_color
            
        check_blue:
            # Check if first color is Blue pill and second is Blue virus
            lw $t2, Blue          # Load Blue pill color (0x0000ff)
            lw $t3, V_Blue        # Load Blue virus color (0x8080FF)
            
            beq $t0, $t2, check_t1_blue
            beq $t0, $t3, check_t1_blue
            j check_yellow
            
        check_t1_blue:
            beq $t1, $t2, same_color
            beq $t1, $t3, same_color
            j different_color
            
        check_yellow:
            # Check if first color is Yellow pill and second is Yellow virus
            lw $t2, Yellow        # Load Yellow pill color (0xffff00)
            lw $t3, V_Yellow      # Load Yellow virus color (0xFFFF99)
            
            beq $t0, $t2, check_t1_yellow
            beq $t0, $t3, check_t1_yellow
            j different_color
            
        check_t1_yellow:
            beq $t1, $t2, same_color
            beq $t1, $t3, same_color
            j different_color
            
        same_color:
            li $v0, 1             # Return 1 (colors match)
            j exit_check_color
            
        different_color:
            li $v0, 0             # Return 0 (colors don't match)
            
        exit_check_color:
            # Restore return address and return
            lw $ra, 8($sp)
            addi $sp, $sp, 12
            
            jr $ra                # Return to caller

  # Remove matching blocks
      
    remove_match:
          # $a0 = starting row, $a1 = starting column, $a2 = length, $a3 = direction (0=horiz, 1=vert)
          addi $sp, $sp, -20
          sw $ra, 16($sp)
          sw $s0, 12($sp)
          sw $s1, 8($sp)
          sw $s2, 4($sp)
          sw $s3, 0($sp)
          
          # Save parameters
          move $s0, $a0       # starting row
          move $s1, $a1       # starting column
          move $s2, $a2       # length
          move $s3, $a3       # direction
          
          beq $s3, $zero , call_horizontal_remove
          beq $s3, 1, call_vertical_remove
          j remove_done  # Invalid direction, do nothing and return
      
          
          call_horizontal_remove:
              # Cal the horizontal removal function
              move $a0, $s0      # Starting row
              move $a1, $s1      # Starting column
              move $a2, $s2      # Length of match
              jal remove_horizontal_match
              j remove_done
      
          call_vertical_remove:
               # Call the vertical removal function
              move $a0, $s0      # Starting row
              move $a1, $s1      # Starting column
              move $a2, $s2      # Length of match
              jal remove_vertical_match
              j remove_done
                  
          remove_done:
              # Restore registers

              # Play Match Removed Sound (A simple two-note chord)
              li $a0, 65           # Pitch (F)
              li $a1, 150          # Duration in ms
              li $a2, 1            # Instrument (Piano)
              li $a3, 100          # Volume
              li $v0, 33
              syscall

              li $a0, 69           # Pitch (A) - Slightly higher note for harmony
              li $a1, 150          # Duration in ms
              li $a2, 1            # Instrument (Piano)
              li $a3, 100          # Volume
              li $v0, 33
              syscall
              

              # Add delay before gravity applies
              li $v0, 32        
              li $a0, 500       # Adjust this value as needed (300 ms is a decent delay)
              syscall
              
              jal Apply_Gravity_Cell
              lw $s3, 0($sp)
              lw $s2, 4($sp)
              lw $s1, 8($sp)
              lw $s0, 12($sp)
              lw $ra, 16($sp)
              addi $sp, $sp, 20
              jr $ra
      
      remove_horizontal_match:
              # $a0 = starting row
              # $a1 = starting column
              # $a2 = length of match (number of blocks to remove)
      
              addi $sp, $sp, -16       # Allocate stack space
              sw $ra, 12($sp)          # Save return address
              sw $a0, 0($sp)           # Save starting row (X)
              sw $a1, 4($sp)           # Save starting column (Y)
              sw $a2, 8($sp)           # Save length of blocks to remove
              
              horizontal_remove_loop:
                  lw $a0, 8($sp)
                  beq $a0, $zero, horizontal_remove_done  # If all blocks removed, exit

                  # Check if the block is virus 
          
                  lw $a0, 0($sp)              # Load starting row
                  lw $a1, 4($sp)              # Load starting column
                  
                  # Call Kill_Pixel to erase block
                  jal Kill_Pixel    

                  # Increment counter
                  lw $a0, 8($sp)
                  addi $a0, $a0, -1
                  sw $a0, 8($sp)
                  lw $a0, 4($sp)
                  addi $a0, $a0, 1
                  sw $a0, 4($sp)
                  
                  j horizontal_remove_loop
      
              horizontal_remove_done:
                  lw $ra, 12($sp)
                  addi $sp, $sp, 16
                  jr $ra
      
      remove_vertical_match:
              # $a0 = starting row
              # $a1 = starting column
              # $a2 = length of match (number of blocks to remove)
              
              addi $sp, $sp, -16
              sw $ra, 12($sp)      # Save return address
              sw $a0, 0($sp)       # Save starting row (X)
              sw $a1, 4($sp)       # Save starting column (Y)
              sw $a2, 8($sp)       # Save length of blocks to remove
          
              vertical_remove_loop:
                  lw $a0, 8($sp)
                  beq $a0, $zero, vertical_remove_done  # If all blocks removed, exit
              
                  lw $a0, 0($sp)         # Load starting row
                  lw $a1, 4($sp)         # Load starting column
              
                  jal Kill_Pixel         # Remove the block
              
                  # Increment counter
                  lw $a0, 8($sp)           
                  addi $a0, $a0, -1
                  sw $a0, 8($sp)
                  lw $a0, 0($sp)
                  addi $a0, $a0, 1
                  sw $a0, 0($sp)
                  
                  j vertical_remove_loop
              
              vertical_remove_done:
                  # Now that all blocks are removed, we move down the column.
              
                  lw $ra, 12($sp)
                  addi $sp, $sp, 16
                  jr $ra
                # Make blocks fall after removing matches        

  # Move Cells Down  
    Move_Column_Down: # moves the unsupported blocks in the column down 
        # Input
        # a_0: Row 
        # a_1: Column
        # Input:
        #   $a0 -> Starting row (The row BELOW which everything should fall)
        #   $a1 -> Starting column (The column to move down)
        
        addi $sp, $sp, -20           # Allocate stack space
        sw $ra, 16($sp)              # Save return address
        sw $a0, 12($sp)              # Save starting row
        sw $a1, 8($sp)               # Save starting column
    
        move_up_loop:
            lw $a0, 12($sp)              # Load current row
            lw $a1, 8($sp)               # Load column index
        
            addi $a0, $a0, -1            # Move to the row above
            sw $a0, 12($sp)
            
            lw $t0, X_L                  # Load topmost row value
            bge $t0, $a0, move_done      # If we've reached the top, stop
            
            # Check if the current cell is a virus
            lw $a0, 12($sp)              # Load current row
            lw $a1, 8($sp)               # Load column index
            jal Check_Virus              # Call your Check_Virus function
            
            bnez $v0, move_up_loop       # If it's a virus, skip and move to the next row above
            
            # Check if the block is a black block
            lw $a0, 12($sp)
            lw $a1, 8($sp)
            jal Get_Color                # Get the color of the current cell
            li $t1, 0x000000             # Black block
            beq $v0, $t1, move_up_loop   # If it's black, skip and move to the next row above
            
            # The block is non-black and non-virus, so let's make it fall
            lw $a0, 12($sp)              # Load row
            lw $a1, 8($sp)               # Load column
            jal Make_Cell_Fall           # Make the block fall
        
            # Continue checking the row above AFTER making the block fall
            j move_up_loop               # Continue checking the next row above
        
        move_done:
            lw $ra, 16($sp)
            addi $sp, $sp, 20
            jr $ra
        
    Apply_Gravity_Cell:
        # This function will trigger Move_Column_Down for each column
        # from the bottom-most playing row upwards.
        # Inputs:
        #   None (Uses global variables X_1 and playing_field_width)
        # Outputs:
        #   None
    
        
        addi $sp, $sp, -32          # Allocate stack space (extra 4 bytes for saving $a2)
        sw $ra, 28($sp)             # Save return address
        sw $a0, 24($sp)
        sw $a1, 20($sp)
        sw $a2, 16($sp)             # Save $a2 properly now!
        sw $a3, 12($sp)
    
        # Load the bottom-most row index
        lw $a0, X_L                 # Load the topmost row index (21)
        lw $a2, map_height          # Load the map height (20)
        add $a0, $a0, $a2           # Calculate bottom-most row index (X_L + map_height)
        addi $a0, $a0, -1           # Subtract 1 to get the index of the last row
        sw $a0, 8($sp)              # Store bottom-most row index on stack
    
        # Load starting column (Y_L + 1)
        lw $a3, Y_L                 # Load the leftmost boundary (Y_L)
        addi $a3, $a3, 1            # Start from the column just to the right of Y_L
        sw $a3, 4($sp)              # Store the current column index on stack
    
        lw $a2, map_width           # Load the map width (25)
        add $a2, $a2, $a3           # Adjust map_width to start from Y_L + 1
        sw $a2, 0($sp)              # Store adjusted width limit to compare against
    
        Apply_Gravity_Loop:
            lw $a3, 4($sp)              # Load current column index from stack
            lw $a2, 0($sp)              # Load width limit (must be reloaded in each loop iteration)
        
            # Check if we've reached the end of the row
            beq $a3, $a2, Apply_Gravity_Done  
        
            # Call Move_Column_Down for the current column
            lw $a0, 8($sp)              # Load starting row (bottom-most row of playing field)
            move $a1, $a3               # Load current column index
            jal Move_Column_Down
            
            # Move to the next column
            lw $a3, 4($sp)
            addi $a3, $a3, 1
            sw $a3, 4($sp)
            j Apply_Gravity_Loop
            
        Apply_Gravity_Done:
            # Restore stack and return
            lw $ra, 28($sp)
            lw $a0, 24($sp)
            lw $a1, 20($sp)
            lw $a2, 16($sp)             # Properly restore $a2
            lw $a3, 12($sp)
            addi $sp, $sp, 32           # Free stack space
            jr $ra
  
    Make_Cell_Fall:
        # Input
        #   $a0 -> Row (Starting row position)
        #   $a1 -> Column (Starting column position)
        # Moves the cell down repeatedly until it hits a solid block or the floor.
    
        addi $sp, $sp, -20      # Allocate stack space
        sw $ra, 16($sp)         # Save return address
        sw $a0, 0($sp)          # Save row (X)
        sw $a1, 4($sp)          # Save column (Y)
    
        fall_loop:
            # Check if the cell is blocked below
            lw $a0, 0($sp)
            lw $a1, 4($sp)
            jal Cell_Blocked_Down  # Check if the cell is blocked below
            
            bnez $v0, fall_done  # If blocked, exit loop
    
            # Move the cell down by one row
            lw $a0, 0($sp)       # Restore row value
            lw $a1, 4($sp)      # Restore column value
            li $a2, 2           # Direction: 2 = Move down
            jal Move_Cell       # Call Move_Cell function to move the block down
    
            # Increment row index after moving down
            lw $a0, 0($sp)
            addi $a0, $a0, 1
            sw $a0, 0($sp)
    
            j fall_loop         # Repeat the loop
        fall_done:
            lw $ra, 16($sp)     # Restore return address
            lw $a0, 0($sp)      # Restore row (X)
            lw $a1, 4($sp)      # Restore column (Y)
            addi $sp, $sp, 20   # Free stack space
            jr $ra
     
    Check_Virus:
        # Input:
        #   $a0 = row (X-coordinate)
        #   $a1 = column (Y-coordinate)
        # Output:
        #   $v0 = 1 if block is a virus, 0 if not a virus
      
        addi $sp, $sp, -12
        sw $ra, 8($sp)
        sw $a0, 4($sp)
        sw $a1, 0($sp)
    
        # Call Get_Color to retrieve the color at the specified row and column
        jal Get_Color
    
        move $t0, $v0  # Save the retrieved color to $t0
    
        # Compare with known virus colors
        la $t1, V_Red
        lw $t1, 0($t1)
        beq $t0, $t1, set_virus
    
        la $t1, V_Blue
        lw $t1, 0($t1)
        beq $t0, $t1, set_virus
    
        la $t1, V_Yellow
        lw $t1, 0($t1)
        beq $t0, $t1, set_virus
    
        # Not a virus
        li $v0, 0
        j check_done
    
        set_virus:
        li $v0, 1   # Mark as virus
        j check_done
    
        check_done:  #####NOtice 
            lw $ra, 8($sp)
            lw $a0, 4($sp)
            lw $a1, 0($sp)
            addi $sp, $sp, 12
            jr $ra

    Cell_Blocked_Down: # Checks if the cell is blocked below
       # Input: 
       #     a0 -> X
       #     a1 -> Y
       # Output:
       #     v0  -> (0 if cell is free, 1 if cell is Blocked)
  
       addi $sp, $sp, -12 # Load stack memory
       sw $ra, 8($sp) # save ra in stack
  
       sw $a0, 0($sp)
       sw $a1, 4($sp)
  
       addi $a0, $a0, 1
       jal Get_Color
  
       bne $v0, 0, set_blocked
  
       li $v0, 0
  
       j Complete_Blocked_Check
  
       set_blocked:
           li $v0, 1
           j Complete_Blocked_Check 
      
       Complete_Blocked_Check:
           lw $ra, 8($sp)
           addi $sp, $sp, 12
  
           jr $ra

  
# Additional Features

  Draw_Mario:
    # Input:
    #   $a0 = X (row) starting position
    #   $a1 = Y (column) starting position

    addi $sp, $sp, -40        # Allocate stack space for variables
    sw $ra, 36($sp)           # Save return address
    sw $a0, 0($sp)            # Save original X position
    sw $a1, 4($sp)            # Save original Y position

    li $a2, 14                 # Sprite width (8 pixels)
    sw $a2, 8($sp)
    li $a3, 17                 # Sprite height (8 pixels)
    sw $a3, 12($sp)
    
    la $t0, Dr_Mario_Sprite   # Load base address of sprite data
    sw $t0, 16($sp)           # Save base address of sprite data

    li $t1, 0                 # Row index (i)
    sw $t1, 20($sp)
    li $t2, 0                 # Column index (j)
    sw $t2, 24($sp)

    Draw_Mario_Loop_Row:
        lw $t1, 20($sp)           # Load row index
        lw $a2, 12($sp)           # Load height
        beq $t1, $a2, Draw_Mario_Done # If all rows are drawn, exit
    
        li $t2, 0                 # Reset column index to 0 for each row
        sw $t2, 24($sp)
    
    Draw_Mario_Loop_Column:
        lw $t2, 24($sp)           # Load column index
        lw $a2, 8($sp)            # Load width
        beq $t2, $a2, Draw_Mario_Next_Row # If all columns are drawn, move to next row
    
        # Load the color from the sprite array
        lw $t0, 16($sp)           # Load sprite base address
        lw $a2, 0($t0)            # Load color
        addi $t0, $t0, 4          # Move to the next pixel in the sprite array
        sw $t0, 16($sp)           # Update sprite base address in stack
    
        # If the pixel is black (0x000000), skip it
        li $t3, 0x000000
        beq $a2, $t3, Skip_Pixel
    
        # Otherwise, draw the pixel
        lw $t4, 0($sp)            # Load original X position
        lw $t5, 4($sp)            # Load original Y position
        lw $t1, 20($sp)           # Load current row index (i)
        lw $t2, 24($sp)           # Load current column index (j)
        add $a0, $t4, $t1         # X position (row) + i
        add $a1, $t5, $t2         # Y position (column) + j
        jal Set_Pixel             # Call your pixel-drawing function
    
    Skip_Pixel:
        lw $t2, 24($sp)           # Load column index
        addi $t2, $t2, 1          # Increment column index
        sw $t2, 24($sp)
        j Draw_Mario_Loop_Column
    
    Draw_Mario_Next_Row:
        lw $t1, 20($sp)           # Load row index
        addi $t1, $t1, 1          # Increment row index
        sw $t1, 20($sp)
        j Draw_Mario_Loop_Row
    
    Draw_Mario_Done:
        lw $ra, 36($sp)           # Restore return address
        addi $sp, $sp, 40         # Free stack space
        jr $ra

  Play_Music:
      addi $sp, $sp, -16
      sw $ra, 0($sp)
      sw $t0, 4($sp)
      sw $t1, 8($sp)
      sw $t2, 12($sp)
  
      # Check if it's time to play a note
      la $t0, dr_mario_sound_threshold
      lw $t1, 0($t0)
      bgtz $t1, decrement_threshold
  
      # Load current step in melody
      la $t0, dr_mario_sound_timer
      lw $t1, 0($t0)
  
      # Play Melody (Lead)
      la $t0, dr_mario_song
      sll $t2, $t1, 2  
      add $t0, $t0, $t2
      lw $t2, 0($t0)
  
      move $a0, $t2   # Pitch
      li $a1, 200     # Duration
      li $a2, 1       # Instrument (Square wave)
      li $a3, 10      # Volume
      li $v0, 31
      syscall
  
      la $t0, dr_mario_bass
      div $t1, $t2  # $t1 / $t2
      mfhi $t3      # $t3 = remainder ($t1 % $t2)
      sll $t2, $t1, 2
      add $t0, $t0, $t2
      lw $t2, 0($t0)
  
      move $a0, $t2   
      li $a1, 200     
      li $a2, 2       # Instrument (Triangle wave)
      li $a3, 10      
      li $v0, 31
      syscall
  
      # Increment to next step in the melody
      la $t0, dr_mario_sound_timer
      lw $t1, 0($t0)
      addi $t1, $t1, 1
  
      # Check if we've reached the end of the melody
      la $t0, dr_note_count
      lw $t2, 0($t0)
      blt $t1, $t2, save_timer
  
      # Reset to beginning of melody
      li $t1, 0
  
      save_timer:
          la $t0, dr_mario_sound_timer
          sw $t1, 0($t0)
      
      decrement_threshold:
          # Decrement sound timer if it's running
          la $t0, dr_mario_sound_threshold
          lw $t1, 0($t0)
          blez $t1, end_music
          addi $t1, $t1, -1
          sw $t1, 0($t0)
      
      end_music:
          lw $ra, 0($sp)
          lw $t0, 4($sp)
          lw $t1, 8($sp)
          lw $t2, 12($sp)
          addi $sp, $sp, 16
          jr $ra          

  draw_paused_sign:
    addi $sp, $sp, -4
    sw $ra, 0($sp)
    
    li $a0, 52          # Y coordinate (row) - near bottom
    li $a1, 10          # X coordinate (column) - near right edge
    jal Draw_P
    
    li $a0, 52
    li $a1, 18          # X position + 8 units
    jal Draw_A
    
    li $a0, 52
    li $a1, 26          # X position + 16 units
    jal Draw_U
    
    li $a0, 52
    li $a1, 34          # X position + 24 units
    jal Draw_S
    
    li $a0, 52
    li $a1, 42          # X position + 32 units
    jal Draw_E
    
    li $a0, 52
    li $a1, 50          # X position + 40 units
    jal Draw_D
    
    lw $ra, 0($sp)
    addi $sp, $sp, 4
    jr $ra
    
    # Draw letter P
    Draw_P:
        addi $sp, $sp, -12
        sw $ra, 8($sp)
        sw $a0, 0($sp) #xcoord
        sw $a1, 4($sp) #ycoord
        
        li $a2, 0xFFFFFF
        
        # Vertical line
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        # Top horizontal
        lw $a0, 0($sp)
        lw $a1, 4($sp)
        addi $a1, $a1, 1
        jal Set_Pixel
        
        addi $a1, $a1, 1
        jal Set_Pixel
        
        # Middle horizontal
        lw $a0, 0($sp)
        addi $a0, $a0, 3
        lw $a1, 4($sp)
        addi $a1, $a1, 1
        jal Set_Pixel
        
        addi $a1, $a1, 1
        jal Set_Pixel
        
        # Right vertical (top half)
        lw $a0, 0($sp)
        addi $a0, $a0, 1
        lw $a1, 4($sp)
        addi $a1, $a1, 3
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        lw $ra, 8($sp)
        addi $sp, $sp, 12
        jr $ra
    
    # Draw letter A
    Draw_A:
        addi $sp, $sp, -12
        sw $ra, 8($sp)
        sw $a0, 0($sp)      # Save Y coordinate
        sw $a1, 4($sp)      # Save X coordinate
        
        li $a2, 0xFFFFFF    # White color
        
        # Left vertical line
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        # Top horizontal
        lw $a0, 0($sp)
        lw $a1, 4($sp)
        addi $a1, $a1, 1
        jal Set_Pixel
        
        addi $a1, $a1, 1
        jal Set_Pixel
        
        # Middle horizontal
        lw $a0, 0($sp)
        addi $a0, $a0, 3
        lw $a1, 4($sp)
        addi $a1, $a1, 1
        jal Set_Pixel
        
        addi $a1, $a1, 1
        jal Set_Pixel
        
        # Right vertical
        lw $a0, 0($sp)
        lw $a1, 4($sp)
        addi $a1, $a1, 3
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        lw $ra, 8($sp)
        addi $sp, $sp, 12
        jr $ra
    
    # Draw letter U
    Draw_U:
        addi $sp, $sp, -12
        sw $ra, 8($sp)
        sw $a0, 0($sp)      # Save Y coordinate
        sw $a1, 4($sp)      # Save X coordinate
        
        li $a2, 0xFFFFFF    # White color
        
        # Left vertical line
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        # Bottom horizontal
        lw $a0, 0($sp)
        addi $a0, $a0, 5
        lw $a1, 4($sp)
        addi $a1, $a1, 1
        jal Set_Pixel
        
        addi $a1, $a1, 1
        jal Set_Pixel
        
        # Right vertical
        lw $a0, 0($sp)
        lw $a1, 4($sp)
        addi $a1, $a1, 3
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        lw $ra, 8($sp)
        addi $sp, $sp, 12
        jr $ra
    
    # Draw letter S
    Draw_S:
        addi $sp, $sp, -12
        sw $ra, 8($sp)
        sw $a0, 0($sp)      # Save Y coordinate
        sw $a1, 4($sp)      # Save X coordinate
        
        li $a2, 0xFFFFFF    # White color
        
        # Top horizontal
        addi $a1, $a1, 1
        jal Set_Pixel
        
        addi $a1, $a1, 1
        jal Set_Pixel
        
        # Top-left vertical
        lw $a0, 0($sp)
        lw $a1, 4($sp)
        addi $a0, $a0, 1
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        # Middle horizontal
        lw $a0, 0($sp)
        addi $a0, $a0, 3
        lw $a1, 4($sp)
        addi $a1, $a1, 1
        jal Set_Pixel
        
        addi $a1, $a1, 1
        jal Set_Pixel
        
        # Bottom-right vertical
        lw $a0, 0($sp)
        addi $a0, $a0, 4
        lw $a1, 4($sp)
        addi $a1, $a1, 3
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        # Bottom horizontal
        lw $a0, 0($sp)
        addi $a0, $a0, 6
        lw $a1, 4($sp)
        addi $a1, $a1, 1
        jal Set_Pixel
        
        addi $a1, $a1, 1
        jal Set_Pixel
        
        lw $ra, 8($sp)
        addi $sp, $sp, 12
        jr $ra
    
    # Draw letter E
    Draw_E:
        addi $sp, $sp, -12
        sw $ra, 8($sp)
        sw $a0, 0($sp)      # Save Y coordinate
        sw $a1, 4($sp)      # Save X coordinate
        
        li $a2, 0xFFFFFF    # White color
        
        # Vertical line
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        # Top horizontal
        lw $a0, 0($sp)
        lw $a1, 4($sp)
        addi $a1, $a1, 1
        jal Set_Pixel
        
        addi $a1, $a1, 1
        jal Set_Pixel
        
        # Middle horizontal
        lw $a0, 0($sp)
        addi $a0, $a0, 3
        lw $a1, 4($sp)
        addi $a1, $a1, 1
        jal Set_Pixel
        
        addi $a1, $a1, 1
        jal Set_Pixel
        
        # Bottom horizontal
        lw $a0, 0($sp)
        addi $a0, $a0, 6
        lw $a1, 4($sp)
        addi $a1, $a1, 1
        jal Set_Pixel
        
        addi $a1, $a1, 1
        jal Set_Pixel
        
        lw $ra, 8($sp)
        addi $sp, $sp, 12
        jr $ra
    
    # Draw letter D
    Draw_D:
        addi $sp, $sp, -12
        sw $ra, 8($sp)
        sw $a0, 0($sp)      # Save Y coordinate
        sw $a1, 4($sp)      # Save X coordinate
        
        li $a2, 0xFFFFFF    # White color
        
        # Vertical line
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        # Top horizontal
        lw $a0, 0($sp)
        lw $a1, 4($sp)
        addi $a1, $a1, 1
        jal Set_Pixel
        
        addi $a1, $a1, 1
        jal Set_Pixel
        
        # Bottom horizontal
        lw $a0, 0($sp)
        addi $a0, $a0, 6
        lw $a1, 4($sp)
        addi $a1, $a1, 1
        jal Set_Pixel
        
        addi $a1, $a1, 1
        jal Set_Pixel
        
        # Right curve
        lw $a0, 0($sp)
        addi $a0, $a0, 1
        lw $a1, 4($sp)
        addi $a1, $a1, 3
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        addi $a0, $a0, 1
        jal Set_Pixel
        
        lw $ra, 8($sp)
        addi $sp, $sp, 12
        jr $ra

  erase_paused_sign:
    addi $sp, $sp, -4
    sw $ra, 0($sp)
    
    # For 512x512 with 8x8 pixels, position in lower right corner
    li $a0, 52          # Y coordinate (row) - near bottom
    li $a1, 10          # X coordinate (column) - near right edge
    jal killP
    
    li $a0, 52
    li $a1, 18          # X position + 8 units
    jal KillA
    
    li $a0, 52
    li $a1, 26          # X position + 16 units
    jal KillU
    
    li $a0, 52
    li $a1, 34          # X position + 24 units
    jal KillS
    
    li $a0, 52
    li $a1, 42          # X position + 32 units
    jal KillE
    
    li $a0, 52
    li $a1, 50          # X position + 40 units
    jal KillD
    
    lw $ra, 0($sp)
    addi $sp, $sp, 4
    jr $ra
    
    # Draw letter P
    killP:
        addi $sp, $sp, -12
        sw $ra, 8($sp)
        sw $a0, 0($sp)      # Save Y coordinate
        sw $a1, 4($sp)      # Save X coordinate
        
        li $a2, 0xFFFFFF    # White color
        
        # Vertical line
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        # Top horizontal
        lw $a0, 0($sp)
        lw $a1, 4($sp)
        addi $a1, $a1, 1
        jal Kill_Pixel
        
        addi $a1, $a1, 1
        jal Kill_Pixel
        
        # Middle horizontal
        lw $a0, 0($sp)
        addi $a0, $a0, 3
        lw $a1, 4($sp)
        addi $a1, $a1, 1
        jal Kill_Pixel
        
        addi $a1, $a1, 1
        jal Kill_Pixel
        
        # Right vertical (top half)
        lw $a0, 0($sp)
        addi $a0, $a0, 1
        lw $a1, 4($sp)
        addi $a1, $a1, 3
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        lw $ra, 8($sp)
        addi $sp, $sp, 12
        jr $ra
    
    # Draw letter A
    KillA:
        addi $sp, $sp, -12
        sw $ra, 8($sp)
        sw $a0, 0($sp)      # Save Y coordinate
        sw $a1, 4($sp)      # Save X coordinate
        
        li $a2, 0xFFFFFF    # White color
        
        # Left vertical line
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        # Top horizontal
        lw $a0, 0($sp)
        lw $a1, 4($sp)
        addi $a1, $a1, 1
        jal Kill_Pixel
        
        addi $a1, $a1, 1
        jal Kill_Pixel
        
        # Middle horizontal
        lw $a0, 0($sp)
        addi $a0, $a0, 3
        lw $a1, 4($sp)
        addi $a1, $a1, 1
        jal Kill_Pixel
        
        addi $a1, $a1, 1
        jal Kill_Pixel
        
        # Right vertical
        lw $a0, 0($sp)
        lw $a1, 4($sp)
        addi $a1, $a1, 3
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        lw $ra, 8($sp)
        addi $sp, $sp, 12
        jr $ra
    
    # Draw Killter U
    KillU:
        addi $sp, $sp, -12
        sw $ra, 8($sp)
        sw $a0, 0($sp)      # Save Y coordinate
        sw $a1, 4($sp)      # Save X coordinate
        
        li $a2, 0xFFFFFF    # White color
        
        # Left vertical line
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        # Bottom horizontal
        lw $a0, 0($sp)
        addi $a0, $a0, 5
        lw $a1, 4($sp)
        addi $a1, $a1, 1
        jal Kill_Pixel
        
        addi $a1, $a1, 1
        jal Kill_Pixel
        
        # Right vertical
        lw $a0, 0($sp)
        lw $a1, 4($sp)
        addi $a1, $a1, 3
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        lw $ra, 8($sp)
        addi $sp, $sp, 12
        jr $ra
    
    # Draw letter S
    KillS:
        addi $sp, $sp, -12
        sw $ra, 8($sp)
        sw $a0, 0($sp)      # Save Y coordinate
        sw $a1, 4($sp)      # Save X coordinate
        
        li $a2, 0xFFFFFF    # White color
        
        # Top horizontal
        addi $a1, $a1, 1
        jal Kill_Pixel
        
        addi $a1, $a1, 1
        jal Kill_Pixel
        
        # Top-left vertical
        lw $a0, 0($sp)
        lw $a1, 4($sp)
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        # Middle horizontal
        lw $a0, 0($sp)
        addi $a0, $a0, 3
        lw $a1, 4($sp)
        addi $a1, $a1, 1
        jal Kill_Pixel
        
        addi $a1, $a1, 1
        jal Kill_Pixel
        
        # Bottom-right vertical
        lw $a0, 0($sp)
        addi $a0, $a0, 4
        lw $a1, 4($sp)
        addi $a1, $a1, 3
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        # Bottom horizontal
        lw $a0, 0($sp)
        addi $a0, $a0, 6
        lw $a1, 4($sp)
        addi $a1, $a1, 1
        jal Kill_Pixel
        
        addi $a1, $a1, 1
        jal Kill_Pixel
        
        lw $ra, 8($sp)
        addi $sp, $sp, 12
        jr $ra
    
    # Draw letter E
    KillE:
        addi $sp, $sp, -12
        sw $ra, 8($sp)
        sw $a0, 0($sp)      # Save Y coordinate
        sw $a1, 4($sp)      # Save X coordinate
        
        li $a2, 0xFFFFFF    # White color
        
        # Vertical line
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        # Top horizontal
        lw $a0, 0($sp)
        lw $a1, 4($sp)
        addi $a1, $a1, 1
        jal Kill_Pixel
        
        addi $a1, $a1, 1
        jal Kill_Pixel
        
        # Middle horizontal
        lw $a0, 0($sp)
        addi $a0, $a0, 3
        lw $a1, 4($sp)
        addi $a1, $a1, 1
        jal Kill_Pixel
        
        addi $a1, $a1, 1
        jal Kill_Pixel
        
        # Bottom horizontal
        lw $a0, 0($sp)
        addi $a0, $a0, 6
        lw $a1, 4($sp)
        addi $a1, $a1, 1
        jal Kill_Pixel
        
        addi $a1, $a1, 1
        jal Kill_Pixel
        
        lw $ra, 8($sp)
        addi $sp, $sp, 12
        jr $ra
    
    # Draw letter D
    KillD:
        addi $sp, $sp, -12
        sw $ra, 8($sp)
        sw $a0, 0($sp)      # Save Y coordinate
        sw $a1, 4($sp)      # Save X coordinate
        
        li $a2, 0xFFFFFF    # White color
        
        # Vertical line
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        # Top horizontal
        lw $a0, 0($sp)
        lw $a1, 4($sp)
        addi $a1, $a1, 1
        jal Kill_Pixel
        
        addi $a1, $a1, 1
        jal Kill_Pixel
        
        # Bottom horizontal
        lw $a0, 0($sp)
        addi $a0, $a0, 6
        lw $a1, 4($sp)
        addi $a1, $a1, 1
        jal Kill_Pixel
        
        addi $a1, $a1, 1
        jal Kill_Pixel
        
        # Right curve
        lw $a0, 0($sp)
        addi $a0, $a0, 1
        lw $a1, 4($sp)
        addi $a1, $a1, 3
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        addi $a0, $a0, 1
        jal Kill_Pixel
        
        lw $ra, 8($sp)
        addi $sp, $sp, 12
        jr $ra

  reset_game:
    addi $sp, $sp, -4
    sw $ra, 0($sp) 

    
    jal GAME_OVER_SCREEN
    li $a0, 10
    li $a1, 20
    jal Draw_Good_Game

    
    wait_for_key:
        la $t0, ADDR_KBRD
        lw $t0, 0($t0)
        lw $t1, 0($t0)
        beq $t1, $zero, wait_for_key
        
        lw $a0, 4($t0)
        
        li $t2, 0x6E   #n key
        beq $a0, $t2, quit_game # If 'q', quit the game
        
        li $t2, 0x79  #y key
        beq $a0, $t2, restart_game
        
        j wait_for_key
    
    quit_game:
        li $v0, 10 
        syscall
    
    restart_game:
        lw $ra, 0($sp) 
        addi $sp, $sp, 4 
        jal close_Game_over_screen
        li $a0, 10
        li $a1, 20
        jal close_gg_sign
        j main 
    
    lw $ra, 0($sp) 
    addi $sp, $sp, 4
    jr $ra 

  GAME_OVER_SCREEN:
    addi $sp, $sp, -16
    sw $ra, 0($sp)
    sw $s0, 4($sp)
    sw $s1, 8($sp)
    sw $s2, 12($sp)
    
    # Clear the screen first
    jal erase_rectangle
    
    # Color for text
    li $s0, 0xFF8080 #Virus red
    
    # Big G
    li $a0, 30 
    li $a1, 25 
    move $a2, $s0
    jal draw_big_G
    
    # 3seconf G
    li $a0, 30 
    li $a1, 35
    move $a2, $s0 
    jal draw_big_G
    
    # Y
    li $a0, 58
    li $a1, 5
    move $a2, $s0
    jal draw_small_Y
    
    # N
    li $a0, 58 
    li $a1, 57
    move $a2, $s0
    jal draw_small_N
    
    lw $s2, 12($sp)
    lw $s1, 8($sp)
    lw $s0, 4($sp)
    lw $ra, 0($sp)
    addi $sp, $sp, 16
    jr $ra

    draw_big_G:
        addi $sp, $sp, -12
        sw $ra, 8($sp)
        sw $a0, 0($sp)
        sw $a1, 4($sp)
        
        # Top horizontal line
        jal Set_Pixel
        addi $a1, $a1, 1
        jal Set_Pixel
        addi $a1, $a1, 1
        jal Set_Pixel
        addi $a1, $a1, 1
        jal Set_Pixel
        
        # Left vertical line
        lw $a0, 0($sp)
        lw $a1, 4($sp)
        addi $a0, $a0, 1
        jal Set_Pixel
        addi $a0, $a0, 1
        jal Set_Pixel
        addi $a0, $a0, 1
        jal Set_Pixel
        addi $a0, $a0, 1
        jal Set_Pixel
        addi $a0, $a0, 1
        jal Set_Pixel
        addi $a0, $a0, 1
        jal Set_Pixel
        
        # Bottom horizontal
        lw $a0, 0($sp)     
        lw $a1, 4($sp) 
        addi $a0, $a0, 7
        addi $a1, $a1, 1
        jal Set_Pixel
        addi $a1, $a1, 1
        jal Set_Pixel
        addi $a1, $a1, 1
        jal Set_Pixel
        
        # Right vertical (bottom half)
        lw $a0, 0($sp)
        lw $a1, 4($sp)
        addi $a0, $a0, 4
        addi $a1, $a1, 3
        jal Set_Pixel
        addi $a0, $a0, 1
        jal Set_Pixel
        addi $a0, $a0, 1
        jal Set_Pixel
        addi $a0, $a0, 1
        jal Set_Pixel
        
        # Middle horizontal line
        lw $a0, 0($sp)
        lw $a1, 4($sp) 
        addi $a0, $a0, 4
        addi $a1, $a1, 2
        jal Set_Pixel
        
        lw $ra, 8($sp)
        addi $sp, $sp, 12
        jr $ra
    
    # Draw a small letter Y
    draw_small_Y:
        addi $sp, $sp, -12
        sw $ra, 8($sp)
        sw $a0, 0($sp)
        sw $a1, 4($sp)
        
        # Left diagonal
        jal Set_Pixel
        addi $a0, $a0, 1
        addi $a1, $a1, 1
        jal Set_Pixel
        
        # Middle vertical
        addi $a0, $a0, 1
        jal Set_Pixel
        
        # Right diagonal
        lw $a0, 0($sp)      
        lw $a1, 4($sp)      
        addi $a1, $a1, 2
        jal Set_Pixel
        addi $a0, $a0, 1
        addi $a1, $a1, -1
        jal Set_Pixel
        
        lw $ra, 8($sp)
        addi $sp, $sp, 12
        jr $ra
    
    draw_small_N:
        addi $sp, $sp, -12
        sw $ra, 8($sp)
        sw $a0, 0($sp)   
        sw $a1, 4($sp)   
        
        # Left vertical
        jal Set_Pixel
        addi $a0, $a0, 1
        jal Set_Pixel
        addi $a0, $a0, 1
        jal Set_Pixel
        
        # Diagonal
        lw $a0, 0($sp)     
        lw $a1, 4($sp)     
        addi $a0, $a0, 1
        addi $a1, $a1, 1
        jal Set_Pixel
        
        # Right vertical
        lw $a0, 0($sp)     
        lw $a1, 4($sp)     
        addi $a1, $a1, 2
        jal Set_Pixel
        addi $a0, $a0, 1
        jal Set_Pixel
        addi $a0, $a0, 1
        jal Set_Pixel
        
        lw $ra, 8($sp)
        addi $sp, $sp, 12
        jr $ra

  close_Game_over_screen:
    addi $sp, $sp, -16
      sw $ra, 0($sp)
      sw $s0, 4($sp)
      sw $s1, 8($sp)
      sw $s2, 12($sp)
      
      # Color for text
      li $s0, 0xFF8080 #Virus red
      
      # Big G
      li $a0, 30 
      li $a1, 25 
      move $a2, $s0
      jal kill_big_G
      
      # 3seconf G
      li $a0, 30 
      li $a1, 35
      move $a2, $s0 
      jal kill_big_G
      
      # Y
      li $a0, 58
      li $a1, 5
      move $a2, $s0
      jal kill_small_Y
      
      # N
      li $a0, 58 
      li $a1, 57
      move $a2, $s0
      jal kill_small_N
      
      lw $s2, 12($sp)
      lw $s1, 8($sp)
      lw $s0, 4($sp)
      lw $ra, 0($sp)
      addi $sp, $sp, 16
      jr $ra
  
      kill_big_G:
          addi $sp, $sp, -12
          sw $ra, 8($sp)
          sw $a0, 0($sp)
          sw $a1, 4($sp)
          
          # Top horizontal line
          jal Kill_Pixel
          addi $a1, $a1, 1
          jal Kill_Pixel
          addi $a1, $a1, 1
          jal Kill_Pixel
          addi $a1, $a1, 1
          jal Kill_Pixel
          
          # Left vertical line
          lw $a0, 0($sp)
          lw $a1, 4($sp)
          addi $a0, $a0, 1
          jal Kill_Pixel
          addi $a0, $a0, 1
          jal Kill_Pixel
          addi $a0, $a0, 1
          jal Kill_Pixel
          addi $a0, $a0, 1
          jal Kill_Pixel
          addi $a0, $a0, 1
          jal Kill_Pixel
          addi $a0, $a0, 1
          jal Kill_Pixel
          
          # Bottom horizontal
          lw $a0, 0($sp)     
          lw $a1, 4($sp) 
          addi $a0, $a0, 7
          addi $a1, $a1, 1
          jal Kill_Pixel
          addi $a1, $a1, 1
          jal Kill_Pixel
          addi $a1, $a1, 1
          jal Kill_Pixel
          
          # Right vertical (bottom half)
          lw $a0, 0($sp)
          lw $a1, 4($sp)
          addi $a0, $a0, 4
          addi $a1, $a1, 3
          jal Kill_Pixel
          addi $a0, $a0, 1
          jal Kill_Pixel
          addi $a0, $a0, 1
          jal Kill_Pixel
          addi $a0, $a0, 1
          jal Kill_Pixel
          
          # Middle horizontal line
          lw $a0, 0($sp)
          lw $a1, 4($sp) 
          addi $a0, $a0, 4
          addi $a1, $a1, 2
          jal Kill_Pixel
          
          lw $ra, 8($sp)
          addi $sp, $sp, 12
          jr $ra
      
      # Draw a small letter Y
      kill_small_Y:
          addi $sp, $sp, -12
          sw $ra, 8($sp)
          sw $a0, 0($sp)
          sw $a1, 4($sp)
          
          # Left diagonal
          jal Kill_Pixel
          addi $a0, $a0, 1
          addi $a1, $a1, 1
          jal Kill_Pixel
          
          # Middle vertical
          addi $a0, $a0, 1
          jal Kill_Pixel
          
          # Right diagonal
          lw $a0, 0($sp)      
          lw $a1, 4($sp)      
          addi $a1, $a1, 2
          jal Kill_Pixel
          addi $a0, $a0, 1
          addi $a1, $a1, -1
          jal Kill_Pixel
          
          lw $ra, 8($sp)
          addi $sp, $sp, 12
          jr $ra
      
      kill_small_N:
          addi $sp, $sp, -12
          sw $ra, 8($sp)
          sw $a0, 0($sp)   
          sw $a1, 4($sp)   
          
          # Left vertical
          jal Kill_Pixel
          addi $a0, $a0, 1
          jal Kill_Pixel
          addi $a0, $a0, 1
          jal Kill_Pixel
          
          # Diagonal
          lw $a0, 0($sp)     
          lw $a1, 4($sp)     
          addi $a0, $a0, 1
          addi $a1, $a1, 1
          jal Kill_Pixel
          
          # Right vertical
          lw $a0, 0($sp)     
          lw $a1, 4($sp)     
          addi $a1, $a1, 2
          jal Kill_Pixel
          addi $a0, $a0, 1
          jal Kill_Pixel
          addi $a0, $a0, 1
          jal Kill_Pixel
          
          lw $ra, 8($sp)
          addi $sp, $sp, 12
          jr $ra

  Draw_Virus_Blue:
    # Input:
    #   $a0 = X (row) starting position
    #   $a1 = Y (column) starting position
    
    addi $sp, $sp, -36        # Allocate stack space for variables
    sw $ra, 32($sp)           # Save return address
    sw $a0, 0($sp)            # Save original X position
    sw $a1, 4($sp)            # Save original Y position
    
    li $a2, 9                 # Sprite width (9 pixels)
    sw $a2, 8($sp)
    li $a3, 9                 # Sprite height (9 pixels)
    sw $a3, 12($sp)
    
    la $t0, Virius_B_Sprite    # Load base address of sprite data
    sw $t0, 16($sp)           # Save base address of sprite data
    
    li $t1, 0                 # Row index (i)
    sw $t1, 20($sp)
    li $t2, 0                 # Column index (j)
    sw $t2, 24($sp)
    Draw_Virus_Blue_Loop_Row:
      lw $t1, 20($sp)           # Load row index
      lw $a3, 12($sp)           # Load height
      beq $t1, $a3, Draw_Virus_Blue_Done # If all rows are drawn, exit
    
      li $t2, 0                 # Reset column index to 0 for each row
      sw $t2, 24($sp)
    
    Draw_Virus_Blue_Loop_Column:
            lw $t2, 24($sp)           # Load column index
            lw $a3, 8($sp)            # Load width
            beq $t2, $a3, Draw_Virus_Blue_Next_Row # If all columns are drawn, move to next row
        
            # Load the color from the sprite array
            lw $t0, 16($sp)           # Load sprite base address
            lw $a2, 0($t0)            # Load color directly from sprite
            addi $t0, $t0, 4          # Move to the next pixel in the sprite array
            sw $t0, 16($sp)           # Update sprite base address in stack
        
            # Draw the pixel (all pixels will be drawn as they have predetermined colors)
            lw $t4, 0($sp)            # Load original X position
            lw $t5, 4($sp)            # Load original Y position
            lw $t1, 20($sp)           # Load current row index (i)
            lw $t2, 24($sp)           # Load current column index (j)
            add $a0, $t4, $t1         # X position (row) + i
            add $a1, $t5, $t2         # Y position (column) + j
            jal Set_Pixel             # Call your pixel-drawing function
        
            lw $t2, 24($sp)           # Load column index
            addi $t2, $t2, 1          # Increment column index
            sw $t2, 24($sp)
            j Draw_Virus_Blue_Loop_Column
        
    Draw_Virus_Blue_Next_Row:
            lw $t1, 20($sp)           # Load row index
            addi $t1, $t1, 1          # Increment row index
            sw $t1, 20($sp)
            j Draw_Virus_Blue_Loop_Row
        
    Draw_Virus_Blue_Done:
            lw $ra, 32($sp)           # Restore return address
            addi $sp, $sp, 36         # Free stack space
            jr $ra

  Draw_Virus_R:
    # Input:
      #   $a0 = X (row) starting position
      #   $a1 = Y (column) starting position
      
      addi $sp, $sp, -36        # Allocate stack space for variables
      sw $ra, 32($sp)           # Save return address
      sw $a0, 0($sp)            # Save original X position
      sw $a1, 4($sp)            # Save original Y position
      
      li $a2, 9                 # Sprite width (9 pixels)
      sw $a2, 8($sp)
      li $a3, 9                 # Sprite height (9 pixels)
      sw $a3, 12($sp)
      
      la $t0, Virius_R_Sprite    # Load base address of sprite data
      sw $t0, 16($sp)           # Save base address of sprite data
      
      li $t1, 0                 # Row index (i)
      sw $t1, 20($sp)
      li $t2, 0                 # Column index (j)
      sw $t2, 24($sp)
      Draw_Virus_Red_Loop_Row:
          lw $t1, 20($sp)           # Load row index
          lw $a3, 12($sp)           # Load height
          beq $t1, $a3, Draw_Virus_Red_Done # If all rows are drawn, exit
      
          li $t2, 0                 # Reset column index to 0 for each row
          sw $t2, 24($sp)
      
      Draw_Virus_Red_Loop_Column:
              lw $t2, 24($sp)           # Load column index
              lw $a3, 8($sp)            # Load width
              beq $t2, $a3, Draw_Virus_Red_Next_Row # If all columns are drawn, move to next row
          
              # Load the color from the sprite array
              lw $t0, 16($sp)           # Load sprite base address
              lw $a2, 0($t0)            # Load color directly from sprite
              addi $t0, $t0, 4          # Move to the next pixel in the sprite array
              sw $t0, 16($sp)           # Update sprite base address in stack
          
              # Draw the pixel (all pixels will be drawn as they have predetermined colors)
              lw $t4, 0($sp)            # Load original X position
              lw $t5, 4($sp)            # Load original Y position
              lw $t1, 20($sp)           # Load current row index (i)
              lw $t2, 24($sp)           # Load current column index (j)
              add $a0, $t4, $t1         # X position (row) + i
              add $a1, $t5, $t2         # Y position (column) + j
              jal Set_Pixel             # Call your pixel-drawing function
          
              lw $t2, 24($sp)           # Load column index
              addi $t2, $t2, 1          # Increment column index
              sw $t2, 24($sp)
              j Draw_Virus_Red_Loop_Column
          
      Draw_Virus_Red_Next_Row:
              lw $t1, 20($sp)           # Load row index
              addi $t1, $t1, 1          # Increment row index
              sw $t1, 20($sp)
              j Draw_Virus_Red_Loop_Row
          
      Draw_Virus_Red_Done:
              lw $ra, 32($sp)           # Restore return address
              addi $sp, $sp, 36         # Free stack space
              jr $ra

  Draw_Virus_Y:
    # Input:
      #   $a0 = X (row) starting position
      #   $a1 = Y (column) starting position
      
      addi $sp, $sp, -36        # Allocate stack space for variables
      sw $ra, 32($sp)           # Save return address
      sw $a0, 0($sp)            # Save original X position
      sw $a1, 4($sp)            # Save original Y position
      
      li $a2, 9                 # Sprite width (9 pixels)
      sw $a2, 8($sp)
      li $a3, 9                 # Sprite height (9 pixels)
      sw $a3, 12($sp)
      
      la $t0, Virius_Y_Sprite    # Load base address of sprite data
      sw $t0, 16($sp)           # Save base address of sprite data
      
      li $t1, 0                 # Row index (i)
      sw $t1, 20($sp)
      li $t2, 0                 # Column index (j)
      sw $t2, 24($sp)
      Draw_Virus_Yellow_Loop_Row:
          lw $t1, 20($sp)           # Load row index
          lw $a3, 12($sp)           # Load height
          beq $t1, $a3, Draw_Virus_Yellow_Done # If all rows are drawn, exit
      
          li $t2, 0                 # Reset column index to 0 for each row
          sw $t2, 24($sp)
      
      Draw_Virus_Yellow_Loop_Column:
              lw $t2, 24($sp)           # Load column index
              lw $a3, 8($sp)            # Load width
              beq $t2, $a3, Draw_Virus_Yellow_Next_Row # If all columns are drawn, move to next row
          
              # Load the color from the sprite array
              lw $t0, 16($sp)           # Load sprite base address
              lw $a2, 0($t0)            # Load color directly from sprite
              addi $t0, $t0, 4          # Move to the next pixel in the sprite array
              sw $t0, 16($sp)           # Update sprite base address in stack
          
              # Draw the pixel (all pixels will be drawn as they have predetermined colors)
              lw $t4, 0($sp)            # Load original X position
              lw $t5, 4($sp)            # Load original Y position
              lw $t1, 20($sp)           # Load current row index (i)
              lw $t2, 24($sp)           # Load current column index (j)
              add $a0, $t4, $t1         # X position (row) + i
              add $a1, $t5, $t2         # Y position (column) + j
              jal Set_Pixel             # Call your pixel-drawing function
          
              lw $t2, 24($sp)           # Load column index
              addi $t2, $t2, 1          # Increment column index
              sw $t2, 24($sp)
              j Draw_Virus_Yellow_Loop_Column
          
      Draw_Virus_Yellow_Next_Row:
              lw $t1, 20($sp)           # Load row index
              addi $t1, $t1, 1          # Increment row index
              sw $t1, 20($sp)
              j Draw_Virus_Yellow_Loop_Row
          
      Draw_Virus_Yellow_Done:
              lw $ra, 32($sp)           # Restore return address
              addi $sp, $sp, 36         # Free stack space
              jr $ra

Draw_Good_Game:
    # Input:
      #   $a0 = X (row) starting position
      #   $a1 = Y (column) starting position
      
      addi $sp, $sp, -36        # Allocate stack space for variables
      sw $ra, 32($sp)           # Save return address
      sw $a0, 0($sp)            # Save original X position
      sw $a1, 4($sp)            # Save original Y position
      
      li $a2, 33                 # Sprite width (9 pixels)
      sw $a2, 8($sp)
      li $a3, 9                 # Sprite height (9 pixels)
      sw $a3, 12($sp)
      
      la $t0, Game_Over_Sign_Sprite    # Load base address of sprite data
      sw $t0, 16($sp)           # Save base address of sprite data
      
      li $t1, 0                 # Row index (i)
      sw $t1, 20($sp)
      li $t2, 0                 # Column index (j)
      sw $t2, 24($sp)
      Draw_Game_Over_Loop_Row:
          lw $t1, 20($sp)           # Load row index
          lw $a3, 12($sp)           # Load height
          beq $t1, $a3, Draw_Game_Over_Done # If all rows are drawn, exit
      
          li $t2, 0                 # Reset column index to 0 for each row
          sw $t2, 24($sp)
      
      Draw_Game_Over_Loop_Column:
              lw $t2, 24($sp)           # Load column index
              lw $a3, 8($sp)            # Load width
              beq $t2, $a3, Draw_Game_Over_Next_Row # If all columns are drawn, move to next row
          
              # Load the color from the sprite array
              lw $t0, 16($sp)           # Load sprite base address
              lw $a2, 0($t0)            # Load color directly from sprite
              addi $t0, $t0, 4          # Move to the next pixel in the sprite array
              sw $t0, 16($sp)           # Update sprite base address in stack
          
              # Draw the pixel (all pixels will be drawn as they have predetermined colors)
              lw $t4, 0($sp)            # Load original X position
              lw $t5, 4($sp)            # Load original Y position
              lw $t1, 20($sp)           # Load current row index (i)
              lw $t2, 24($sp)           # Load current column index (j)
              add $a0, $t4, $t1         # X position (row) + i
              add $a1, $t5, $t2         # Y position (column) + j
              jal Set_Pixel             # Call your pixel-drawing function
          
              lw $t2, 24($sp)           # Load column index
              addi $t2, $t2, 1          # Increment column index
              sw $t2, 24($sp)
              j Draw_Game_Over_Loop_Column
          
      Draw_Game_Over_Next_Row:
              lw $t1, 20($sp)           # Load row index
              addi $t1, $t1, 1          # Increment row index
              sw $t1, 20($sp)
              j Draw_Game_Over_Loop_Row
          
      Draw_Game_Over_Done:
              lw $ra, 32($sp)           # Restore return address
              addi $sp, $sp, 36         # Free stack space
              jr $ra


  Accelerate_Gravity:
      addi $sp, $sp, -8         # Allocate stack space
      sw $ra, 4($sp)
      sw $t0, 0($sp)
    
      # Load current speed timer
      la $t0, gravity_speed_timer
      lw $t1, 0($t0)
    
      # Increment the speed timer
      addi $t1, $t1, 1
      sw $t1, 0($t0)
    
      # Load acceleration rate (How often to speed up)
      la $t2, gravity_acceleration_rate
      lw $t3, 0($t2)
    
      bne $t1, $t3, gravity_done   # Continue if the speed timer hasn't reached the rate
    
      # Reset speed timer
      li $t1, 0
      sw $t1, 0($t0)
    
      # Load current gravity threshold
      la $t0, gravity_threshold
      lw $t1, 0($t0)
      
      # Load minimum threshold
      la $t2, min_gravity_threshold
      lw $t3, 0($t2)
      
      # Check if we can decrease gravity threshold further
      ble $t1, $t3, gravity_done  # If it's already at minimum, skip
    
      # Decrease gravity threshold slightly to increase speed
      addi $t1, $t1, -1
      sw $t1, 0($t0)

      # Slightly increase gravity increment for faster acceleration
      la $t4, gravity_increment
      lw $t5, 0($t4)
      addi $t5, $t5, 1
      sw $t5, 0($t4)
    
    gravity_done:
        lw $ra, 4($sp)
        lw $t0, 0($sp)
        addi $sp, $sp, 8
        jr $ra

close_gg_sign:
    # Input:
      #   $a0 = X (row) starting position
      #   $a1 = Y (column) starting position
      
      addi $sp, $sp, -36        # Allocate stack space for variables
      sw $ra, 32($sp)           # Save return address
      sw $a0, 0($sp)            # Save original X position
      sw $a1, 4($sp)            # Save original Y position
      
      li $a2, 33                 # Sprite width (9 pixels)
      sw $a2, 8($sp)
      li $a3, 9                 # Sprite height (9 pixels)
      sw $a3, 12($sp)
      
      la $t0, Erase_Game_Over_Sign_Sprite    # Load base address of sprite data
      sw $t0, 16($sp)           # Save base address of sprite data
      
      li $t1, 0                 # Row index (i)
      sw $t1, 20($sp)
      li $t2, 0                 # Column index (j)
      sw $t2, 24($sp)
      erase_Game_Over_Loop_Row:
          lw $t1, 20($sp)           # Load row index
          lw $a3, 12($sp)           # Load height
          beq $t1, $a3, erase_Game_Over_Done # If all rows are drawn, exit
      
          li $t2, 0                 # Reset column index to 0 for each row
          sw $t2, 24($sp)
      
      erase_Game_Over_Loop_Column:
              lw $t2, 24($sp)           # Load column index
              lw $a3, 8($sp)            # Load width
              beq $t2, $a3, erase_Game_Over_Next_Row # If all columns are drawn, move to next row
          
              # Load the color from the sprite array
              lw $t0, 16($sp)           # Load sprite base address
              lw $a2, 0($t0)            # Load color directly from sprite
              addi $t0, $t0, 4          # Move to the next pixel in the sprite array
              sw $t0, 16($sp)           # Update sprite base address in stack
          
              # Draw the pixel (all pixels will be drawn as they have predetermined colors)
              lw $t4, 0($sp)            # Load original X position
              lw $t5, 4($sp)            # Load original Y position
              lw $t1, 20($sp)           # Load current row index (i)
              lw $t2, 24($sp)           # Load current column index (j)
              add $a0, $t4, $t1         # X position (row) + i
              add $a1, $t5, $t2         # Y position (column) + j
              jal Kill_Pixel            # Call your pixel-drawing function
          
              lw $t2, 24($sp)           # Load column index
              addi $t2, $t2, 1          # Increment column index
              sw $t2, 24($sp)
              j erase_Game_Over_Loop_Column
          
      erase_Game_Over_Next_Row:
              lw $t1, 20($sp)           # Load row index
              addi $t1, $t1, 1          # Increment row index
              sw $t1, 20($sp)
              j erase_Game_Over_Loop_Row
          
      erase_Game_Over_Done:
              lw $ra, 32($sp) 
              addi $sp, $sp, 36 
              jr $ra

#############################################
######      Under Construction       ########
#############################################

        
